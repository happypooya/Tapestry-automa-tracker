<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tapestry Automa Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            height: 100%; /* Explicitly set height to 100% */
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
            overflow-y: auto; /* Ensure both html and body are scrollable */
            position: relative; /* Needed for the ::before pseudo-element */
        }

        body {
            font-family: 'Inter', sans-serif;
            color: #333;
            min-height: 100vh; /* Ensure body has a minimum height for scrolling */
            /* Remove background image and filter from body */
            background-image: none;
            filter: none;
            -webkit-filter: none;
        }

        /* Pseudo-element for the blurred background image (Main App Background) */
        body::before {
            content: '';
            position: fixed; /* Fix it to the viewport */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Set the background image here using the *previous* provided URL for the main app */
            background-image: url('https://cf.geekdo-images.com/CdvEboFCixBAMi9HYOS83g__imagepagezoom/img/34mgZz2a9OX4JMEF4TdHel8eRZw=/fit-in/1200x900/filters:no_upscale():strip_icc()/pic6221971.jpg');
            background-size: cover; /* Cover the entire background */
            background-position: center; /* Center the background image */
            background-attachment: fixed; /* Keep the background fixed while scrolling */
            /* Apply the blur filter to the pseudo-element */
            filter: blur(2px); /* Adjust the pixel value for more or less blur */
            -webkit-filter: blur(2px); /* For Safari */
            z-index: -1; /* Send it behind all content */
        }


        /* Add a class to body to disable scrolling when modal is open */
        body.modal-open {
            overflow: hidden;
        }

        /* Style for the main content container to ensure it's above the blurred background */
         #app > .container {
             position: relative; /* Ensure positioning context for z-index */
             z-index: 1; /* Place it above the blurred background (z-index: -1) */
             /* No filter needed here anymore */
             filter: none;
             -webkit-filter: none;
         }


        .container {
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            padding-left: 1rem;
            padding-right: 1rem;
            /* Ensure no conflicting overflow properties */
            overflow-y: visible;
            overflow-x: hidden; /* Prevent horizontal overflow from tracks */
        }

        /* Style for the main title to make it visible through the background */
        h1 {
            background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent white background for readability */
            padding: 0.5rem 1rem; /* Add some padding around the text */
            border-radius: 8px; /* Rounded corners for the background */
            display: inline-block; /* Make the background wrap the text */
            margin-bottom: 1.5rem; /* Keep existing margin below */
            position: relative; /* Ensure positioning context */
            z-index: 2; /* Ensure it's above the blurred background and container's base level */
         }


         .track-space {
            position: relative; /* Needed for tooltip positioning */
            border: 2px solid #a1887f; /* Earthy border */
            background-color: #d7ccc8; /* Lighter earthy background */
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out; /* Added background-color transition */
            cursor: pointer;
            box-shadow: 2px 2+px 4px rgba(0,0,0,0.2);
            min-width: 96px; /* Ensure spaces have a minimum width */
            display: flex; /* Use flexbox for centering content */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px; /* Add some padding */
            text-align: center;
            border-radius: 8px; /* Added rounded corners */
            z-index: 1; /* Ensure track spaces have a z-index */
         }

         .track-space:hover {
             transform: translateY(-3px);
             box-shadow: 4px 4px 8px rgba(0,0,0,0.3);
             background-color: #e0e0e0; /* Slightly lighter on hover */
         }

        /* Style for the Start space (space 0) */
        .track-space.start-space {
            background-color: #b0bec5 !important; /* Gray background - using !important for specificity */
            border-color: #78909c !important; /* Darker gray border - using !important */
        }
         .track-space.start-space:hover {
             background-color: #c0c0c0 !important; /* Lighter gray on hover */
         }


        .tooltip {
            visibility: hidden;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 8px;
            position: absolute;
            z-index: 20; /* Increased z-index */
            bottom: 130%; /* Adjusted positioning slightly */
            left: 50%;
            transform: translateX(-50%); /* Center the tooltip precisely */
            opacity: 0;
            transition: opacity 0.3s;
            width: 150px; /* Adjusted width */
            white-space: normal; /* Allow text to wrap */
            font-size: 0.75rem; /* Smaller font size for tooltip */
            pointer-events: none; /* Allow clicking through tooltip */
        }

        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
        }

        .track-space:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Track specific colors - Corrected based on user feedback */
        .track-exploration .track-space { border-color: #42a5f5; background-color: #e3f2fd; } /* Blue (Unchanged) */
        .track-exploration .track-space:hover { background-color: #cce5ff; } /* Lighter blue on hover */
        .track-technology .track-space { border-color: #f59e0b; background-color: #fef3c7; } /* Yellow (Corrected) */
        .track-technology .track-space:hover { background-color: #fde68a; } /* Lighter yellow on hover */
        .track-science .track-space { border-color: #66bb6a; background-color: #e8f5e9; } /* Green (Corrected) */
        .track-science .track-space:hover { background-color: #d0f0d0; } /* Lighter green on hover */
        .track-military .track-space { border-color: #ef5350; background-color: #ffebee; } /* Red (Unchanged) */
        .track-military .track-space:hover { background-color: #ffcccb; } /* Lighter red on hover */
        .track-arts .track-space { border-color: #ab47bc; background-color: #f3e5f5; } /* Purple (Corrected) */
        .track-arts .track-space:hover { background-color: #e1bee7; } /* Lighter purple on hover */


        .track-exploration .track-space.tier-start { border-color: #1565c0; border-width: 3px; }
        .track-technology .track-space.tier-start { border-color: #d97706; border-width: 3px; } /* Darker Yellow */
        .track-science .track-space.tier-start { border-color: #388e3c; border-width: 3px; } /* Darker Green */
        .track-military .track-space.tier-start { border-color: #c62828; border-width: 3px; }
        .track-arts .track-space.tier-start { border-color: #7b1fa2; border-width: 3px; } /* Darker Purple */

        .tier-marker {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            font-weight: bold;
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 1px 4px;
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
            z-index: 5;
        }

        /* Styles for the landmark info on the space */
        .landmark-info-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 4px;
        }

        .landmark-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-bottom: 2px; /* Space between icon and name */
        }

         .landmark-name {
            font-size: 0.6rem; /* Smaller font for landmark name */
            text-align: center;
            color: #555;
            line-height: 1; /* Adjust line height */
         }

         .landmark-name.taken {
             color: #a1a1aa; /* Tailwind gray-400 for greyed out */
             font-style: italic;
         }

        /* Automa Panel Enhancements */
        .automa-panel {
             border-radius: 8px;
             padding: 24px;
             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
             margin-bottom: 2rem; /* Increased bottom margin */
             z-index: 10; /* Ensure it stays above other content */
             overflow: hidden; /* Hide overflow from background effects */
             width: 100%; /* Ensure it spans the full width */
             box-sizing: border-box; /* Include padding and border in the element's total width and height */
             display: block; /* Ensure it behaves as a block element */
             isolation: isolate; /* Create a new stacking context */
        }

        /* Pseudo-element for background effects */
        .automa-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 0; /* Send behind content */
            opacity: 0.8; /* Adjust opacity as needed */
            pointer-events: none; /* Allow clicks to pass through */
        }

        .automa-panel > * {
            position: relative; /* Ensure content is above the background pseudo-element */
            z-index: 1;
        }


        .automa-panel h3 {
             font-weight: bold;
             margin-bottom: 12px;
             position: relative; /* Ensure heading is above background */
             z-index: 1;
        }

        .automa-buildings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 12px; /* Increased gap */
            margin-top: 15px;
            padding-top: 15px; /* Increased padding */
            border-top: 1px solid rgba(255, 255, 255, 0.3);
             padding-bottom: 15px; /* Increased bottom padding */
             margin-bottom: 15px; /* Increased bottom margin */
        }

        .automa-buildings-grid .building-item {
             display: flex;
             flex-direction: column;
             align-items: center;
             padding: 10px; /* Increased padding */
             border-radius: 6px; /* Slightly larger border radius */
             background-color: rgba(255, 255, 255, 0.9); /* More opaque white background */
             font-size: 0.9rem; /* Increased font size */
             font-weight: 700; /* Bolder font */
             text-align: center;
             border: 1px solid rgba(0, 0, 0, 0.15); /* Slightly stronger border */
             box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.15); /* Slightly stronger shadow */
             transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; /* Added transition */
        }

         /* Specific background and text colors for buildings */
         .building-item.market-color { background-color: #fef08a; color: #a16207; border-color: #f59e0b; } /* Tailwind yellow-200, yellow-800, yellow-500 */
         .building-item.farm-color { background-color: #d97706; color: #fef3c7; border-color: #b45309; } /* Tailwind amber-700, yellow-100, amber-800 */
         .building-item.house-color { background-color: #d1d5db; color: #374151; border-color: #9ca3af; } /* Tailwind gray-300, gray-700, gray-400 */


        /* Landmark Status Control Section */
        .landmark-control-section {
            background-color: #e8f5e9; /* Light green background */
            border-color: #a5d6a7; /* Lighter green border */
             border-radius: 8px; /* Added rounded corners */
        }

        .landmark-control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); /* Responsive grid */
            gap: 15px;
        }

        .landmark-group {
            border: 1px solid #c8e6c9;
            border-radius: 4px;
            padding: 10px;
            background-color: #f1f8e9;
        }

        .landmark-group h4 {
            font-size: 1rem;
            font-weight: bold;
            margin-bottom: 8px;
            border-bottom: 1px solid #d5e8d6;
            padding-bottom: 4px;
        }


        .landmark-item {
            display: flex;
            align-items: center;
            padding: 4px 0; /* Reduced padding */
            border-radius: 4px;
        }

        .landmark-item span {
            flex-grow: 1;
            margin-right: 10px;
            font-weight: 500;
            font-size: 0.9rem; /* Adjusted font size */
        }

        .landmark-item select {
             padding: 4px;
             border-radius: 4px;
             border: 1px solid #a5d6a7;
             background-color: #fff;
             cursor: pointer;
             font-size: 0.9rem; /* Adjusted font size */
        }

        .disabled-button {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Modal Overlay Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50; /* Higher z-index than other elements */
            overflow-y: auto; /* Add scrollbar to overlay if content overflows */
        }

        .modal-content {
            background-color: #fff;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 90vh; /* Limit height to prevent overflow */
            overflow-y: auto; /* Add scrollbar to modal content if it overflows */
        }

         .modal-content h4 {
             font-size: 1.25rem; /* Tailwind text-xl */
             font-weight: bold; /* Tailwind font-bold */
             margin-bottom: 16px; /* Tailwind mb-4 */
             color: #333;
         }

         .modal-content label {
             display: block;
             margin-bottom: 8px;
             font-weight: 500;
         }

         .modal-content input[type="number"],
         .modal-content select {
              width: 100%;
              padding: 8px;
              margin-bottom: 16px;
              border: 1px solid #ccc;
              border-radius: 4px;
         }

         .modal-buttons {
             display: flex;
             justify-content: flex-end;
             gap: 12px; /* Tailwind space-x-3 */
             margin-top: 20px;
         }

         .modal-buttons button {
             padding: 8px 16px;
             border-radius: 4px;
             font-weight: bold;
             transition: background-color 0.2s ease-in-out;
         }

         .modal-buttons .confirm-button {
             background-color: #48bb78; /* Tailwind bg-green-500 */
             color: white;
         }

         .modal-buttons .confirm-button:hover {
             background-color: #38a169; /* Tailwind bg-green-600 */
         }

         .modal-buttons .cancel-button {
             background-color: #e2e8f0; /* Tailwind bg-gray-200 */
             color: #2d3748; /* Tailwind text-gray-800 */
         }

         .modal-buttons .cancel-button:hover {
             background-color: #cbd5e0; /* Tailwind bg-gray-300 */
         }

        /* Styles for the Building Adjustment Modal */
        .building-adjust-modal .modal-content {
            max-width: 350px; /* Smaller modal for building adjustment */
        }

        .building-adjust-modal .building-input-group {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .building-adjust-modal .building-input-group label {
            flex-grow: 1;
            margin-bottom: 0;
            margin-right: 10px;
        }

        .building-adjust-modal .building-input-group input[type="number"] {
            width: 80px; /* Fixed width for number input */
            margin-bottom: 0;
        }

         /* Styles for Position Adjustment Modal */
         .position-adjust-modal .modal-content {
             max-width: 400px; /* Adjusted width */
         }

         .position-adjust-modal .track-position-group {
             margin-bottom: 15px;
             padding-bottom: 10px;
             border-bottom: 1px solid #eee;
         }

         .position-adjust-modal .track-position-group:last-child {
             border-bottom: none;
             padding-bottom: 0;
             margin-bottom: 0;
         }

         .position-adjust-modal .track-position-group h5 {
             font-weight: bold;
             margin-bottom: 8px;
             font-size: 1rem;
         }

         .position-adjust-modal .position-input-row {
             display: flex;
             align-items: center;
             gap: 15px; /* Space between inputs */
         }

         .position-adjust-modal .position-input-row label {
             flex-basis: 100px; /* Fixed width for labels */
             flex-shrink: 0; /* Prevent shrinking */
             margin-bottom: 0;
         }

         .position-adjust-modal .position-input-row input[type="number"] {
             flex-grow: 1; /* Allow input to take remaining space */
             width: auto; /* Override default width: 100% */
             margin-bottom: 0;
         }


        /* Automa Color Styles - Panel Background, Border, and Text */
        /* Using gradients and more complex backgrounds */
        .automa-blue {
            background: linear-gradient(135deg, #bfdbfe 0%, #60a5fa 100%) !important; /* Blue gradient */
            border-color: #3b82f6 !important; /* Darker blue border */
            color: #1e3a8a; /* Dark blue text */
        }
        .automa-blue::before {
             background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="none" stroke="%2393c5fd" stroke-width="8"/></svg>'); /* Subtle circle pattern */
             background-size: 20px 20px;
             opacity: 0.3; /* Adjust opacity */
        }


        .automa-red {
            background: linear-gradient(135deg, #fecaca 0%, #f87171 100%) !important; /* Red gradient */
            border-color: #ef4444 !important; /* Darker red border */
            color: #991b1b; /* Dark red text */
        }
         .automa-red::before {
             background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><line x1="0" y1="0" x2="100" y2="100" stroke="%23fca5a5" stroke-width="2"/><line x1="100" y1="0" x2="0" y2="100" stroke="%23fca5a5" stroke-width="2"/></svg>'); /* Subtle crosshatch pattern */
             background-size: 20px 20px;
             opacity: 0.3;
         }


        .automa-green {
            background: linear-gradient(135deg, #dcfce7 0%, #4ade80 100%) !important; /* Green gradient */
            border-color: #10b981 !important; /* Darker green border */
            color: #14532d; /* Dark green text */
        }
         .automa-green::before {
             background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%23bbf7d0" opacity="0.5"/></svg>'); /* Subtle green circles */
             background-size: 20px 20px;
             opacity: 0.4;
         }


        .automa-yellow {
            background: linear-gradient(135deg, #fef9c3 0%, #facc15 100%) !important; /* Yellow gradient */
            border-color: #f59e0b !important; /* Darker yellow border */
            color: #a16207; /* Dark yellow text */
        }
         .automa-yellow::before {
             background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M50 0 L61.8 38.2 L100 38.2 L69.1 61.8 L80.9 100 L50 76.4 L19.1 100 L30.9 61.8 L0 38.2 L38.2 38.2 Z" fill="%23fde68a" opacity="0.5"/></svg>'); /* Subtle star pattern */
             background-size: 20px 20px;
             opacity: 0.4;
         }


        .automa-milky-white {
            background: linear-gradient(135deg, #f3f4f6 0%, #d1d5db 100%) !important; /* Gray gradient */
            border-color: #9ca3af !important; /* Darker gray border */
            color: #374151; /* Dark gray text */
        }
         .automa-milky-white::before {
             background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="10" height="10" fill="%23e5e7eb" opacity="0.5"/></svg>'); /* Subtle square pattern */
             background-size: 20px 20px;
             opacity: 0.4;
         }


        /* Automa Turn Button Colors */
        .automa-button-blue { background-color: #2563eb; color: white; } /* Tailwind blue-600 */
        .automa-button-blue:hover { background-color: #1d4ed8; } /* Tailwind blue-700 */
        .automa-button-red { background-color: #dc2626; color: white; } /* Tailwind red-600 */
        .automa-button-red:hover { background-color: #b91c1c; } /* Tailwind red-700 */
        .automa-button-green { background-color: #16a34a; color: white; } /* Tailwind green-600 */
        .automa-button-green:hover { background-color: #15803d; } /* Tailwind green-700 */
        .automa-button-yellow { background-color: #d97706; color: white; } /* Tailwind amber-700 */
        .automa-button-yellow:hover { background-color: #b45309; } /* Tailwind amber-800 */
        .automa-button-milky-white { background-color: #6b7280; color: white; } /* Tailwind gray-600 */
        .automa-button-milky-white:hover { background-color: #4b5563; } /* Tailwind gray-700 */

        /* Setup Screen Styles */
        .setup-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            /* Background image for setup screen - Using the provided URL */
            background-image: url('https://canada.stonemaiergames.com/cdn/shop/products/A05I6187-PhotographyByTimChuon.jpg?v=1722592311');
            background-size: cover;
            background-position: center;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 60; /* Higher than modals */
            padding: 20px; /* Add some padding for smaller screens */
        }

        .setup-content {
            background-color: rgba(255, 255, 255, 0.9); /* Semi-transparent white background */
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 400px; /* Limit width */
            width: 100%; /* Make it responsive */
        }

        .setup-content h2 {
            font-size: 1.75rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .setup-input-group {
            margin-bottom: 15px;
            text-align: left; /* Align labels and selects to the left */
        }

        .setup-input-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 5px;
            color: #555;
        }

        .setup-input-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 1rem;
            background-color: #fff;
        }

        .start-game-button {
            background-color: #48bb78; /* Tailwind green-500 */
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
            margin-top: 20px;
        }

        .start-game-button:hover {
            background-color: #38a169; /* Tailwind green-600 */
        }

        /* Button Group Styling */
        .button-group {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            justify-content: center; /* Center buttons */
            gap: 1rem; /* Space between buttons */
            margin-top: 1.5rem; /* Space above the button group */
            margin-bottom: 1.5rem; /* Space below the button group */
            padding: 1rem; /* Add padding */
            background-color: rgba(255, 255, 255, 0.8); /* Light background for readability */
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .button-group button {
             padding: 0.75rem 1.5rem; /* Increased padding */
             font-size: 1rem; /* Standard font size */
             border-radius: 0.5rem; /* Rounded corners */
             font-weight: 600; /* Semi-bold font */
             transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .button-group button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.15);
        }

         /* Specific Button Colors */
         .button-group .automa-turn-button {
             background-color: #f59e0b; /* Tailwind amber-500 */
             color: white;
         }
         .button-group .automa-turn-button:hover {
             background-color: #d97706; /* Tailwind amber-700 */
         }

         .button-group .player-income-button {
             background-color: #3b82f6; /* Tailwind blue-500 */
             color: white;
         }
         .button-group .player-income-button:hover {
             background-color: #2563eb; /* Tailwind blue-600 */
         }

         .button-group .undo-button {
             background-color: #6b7280; /* Tailwind gray-500 */
             color: white;
         }
         .button-group .undo-button:hover {
             background-color: #4b5563; /* Tailwind gray-700 */
         }

         .button-group .redo-button {
             background-color: #6b7280; /* Tailwind gray-500 */
             color: white;
         }
         .button-group .redo-button:hover {
             background-color: #4b5563; /* Tailwind gray-700 */
         }

         .button-group .restart-button {
             background-color: #ef4444; /* Tailwind red-500 */
             color: white;
         }
         .button-group .restart-button:hover {
             background-color: #dc2626; /* Tailwind red-600 */
         }

         .button-group button:disabled {
             opacity: 0.5;
             cursor: not-allowed;
             transform: none; /* Prevent hover transform when disabled */
             box-shadow: none; /* Prevent hover shadow when disabled */
         }


    </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
</head>
<body class="bg-gray-50">
    <div id="app">
        </div>

    <script type="text/babel">
        // Define the structure of each track with space details and structured benefits
        const tracksData = {
            Exploration: {
                name: 'Exploration',
                tiers: [0, 4, 7, 10], // Space numbers where tiers start (0 is Tier I, 4 is Tier II, etc.)
                landmarks: [
                    { space: 4, name: 'Lighthouse' },
                    { space: 7, name: 'Train Station' },
                    { space: 10, name: 'Launch Pad' },
                ],
                // Corrected cost function based on user's feedback (Tier IV costs 2)
                cost: (space) => {
                    if (space < 4) return 1; // Tier I (spaces 1-3) cost 1 to enter
                    if (space < 7) return 2; // Tier II (spaces 4-6) cost 2 to enter
                    if (space < 10) return 3; // Tier III (spaces 7-9) cost 3 to enter
                    // Tier IV (spaces 10-12) cost 2 to enter based on user feedback
                    if (space >= 10 && space <= 12) return 2;
                    return 1; // Default for space 0 (cost to move to space 1)
                },
                spacesData: [
                    { number: 0, name: 'Start', benefit: 'Starting Space', benefitDetails: {} },
                    { number: 1, name: 'SCOUTING', benefit: 'Gain 2 territory tiles.', benefitDetails: {} },
                    { number: 2, name: 'RAFTS', benefit: 'Explore: Place 1 territory tile from your supply on the map, gain 1 VP per aligning side, and gain the benefit on the tile. [BONUS: Spend 1 resource. Gain 1 Tapestry card.]', benefitDetails: {} },
                    { number: 3, name: 'WAGONS', benefit: 'Explore OR gain 1 farm.', benefitDetails: { gainBuilding: 'Farm' } },
                    { number: 4, name: 'NAVIGATION', benefit: 'Gain 1 territory tile, then explore. [LANDMARK: Lighthouse]', benefitDetails: {} },
                    { number: 5, name: 'SHIPS', benefit: 'Gain 1 VP for each territory you control. [BONUS: Spend 1 resource. Gain 1 farm.]', benefitDetails: { gainBuilding: 'Farm' } },
                    { number: 6, name: 'TUNNELS', benefit: 'Gain 1 territory tile and 1 farm. [BONUS: Spend 1 resource. Explore.]', benefitDetails: { gainBuilding: 'Farm' } },
                    { number: 7, name: 'TRAINS', benefit: 'Gain 2 territory tiles, then explore. [LANDMARK: Train Station]', benefitDetails: {} },
                    { number: 8, name: 'CARS', benefit: 'Gain 1 farm, then gain 1 VP for each farm in your capital city. [BONUS: Spend 2 territory tiles. Gain 5 VP.]', benefitDetails: { gainBuilding: 'Farm' } },
                    { number: 9, name: 'AIRPLANES', benefit: 'Gain 2 territory tiles, then explore anywhere on the map. [BONUS: Spend 1 resource. Gain 1 Tapestry card.]', benefitDetails: {} },
                    { number: 10, name: 'SPACE SHUTTLE', benefit: 'Gain 1 VP per technology track space you’ve advanced. [BONMARK: Launch Pad]', benefitDetails: {} },
                    { number: 11, name: 'INTERSTELLAR TRAVEL', benefit: 'Gain 3 space tiles, then explore 1 of them (place explored space tiles next to your income mat).', benefitDetails: {} },
                    { number: 12, name: 'WARPGATES', benefit: 'Explore a space tile from your supply. [BONUS: Spend 1 resource. Explore a space tile from your supply]', benefitDetails: {} }, // Using custom name as requested
                ]
            },
            Technology: {
                name: 'Technology',
                tiers: [0, 4, 7, 10],
                landmarks: [
                     { space: 4, name: 'Forge' },
                     { space: 7, name: 'Rubber Factory' }, // Corrected name from PDF based on allLandmarksCategorized
                     { space: 10, name: 'Tech Hub' },
                ],
                 // Corrected cost function based on user's feedback (Tier IV costs 2)
                cost: (space) => {
                    if (space < 4) return 1; // Tier I (spaces 1-3) cost 1 to enter
                    if (space < 7) return 2; // Tier II (spaces 4-6) cost 2 to enter
                    if (space < 10) return 3; // Tier III (spaces 7-9) cost 3 to enter
                    // Tier IV (spaces 10-12) cost 2 to enter based on user feedback
                    if (space >= 10 && space <= 12) return 2;
                    return 1; // Default for space 0 (cost to move to space 1)
                },
                 spacesData: [
                    { number: 0, name: 'Start', benefit: 'Starting Space', benefitDetails: {} },
                    { number: 1, name: 'POTTERY', benefit: 'Invent: Gain 1 tech card and place it to the right of your capital city mat in the bottom row. If you gained a faceup card, replenish it immediately.', benefitDetails: {} },
                    { number: 2, name: 'CARPENTRY', benefit: 'Gain 1 tapestry card. [BONUS: Spend 1 resource. Gain 1 market.]', benefitDetails: { gainBuilding: 'Market' } },
                    { number: 3, name: 'STONE TOOLS', benefit: 'Invent 1 tech card OR gain 1 market.', benefitDetails: { gainBuilding: 'Market' } },
                    { number: 4, name: 'METALLURGY', benefit: 'You may discard all 3 face-up tech cards and replace them. Invent 1 tech card. [LANDMARK: Forge]', benefitDetails: {} },
                    { number: 5, name: 'GLASS', benefit: 'Gain either a farm, house, or armory. [BONUS: Spend 1 resource. Upgrade 1 tech card.]', benefitDetails: { gainBuildingChoice: ['Farm', 'House', 'Armory'] } },
                    { number: 6, name: 'STEEL', benefit: 'Gain 1 VP for each armory in your capital city and gain 1 market. [BONUS: Spend 1 resource. Invent 1 tech card.]', benefitDetails: { gainBuilding: 'Market' } },
                    { number: 7, name: 'RUBBER', benefit: 'You may discard all 3 face-up tech cards and replace them. Invent 2 tech cards (one at a time). [LANDMARK: Rubber Factory]', benefitDetails: {} }, // Corrected landmark name
                    { number: 8, name: 'PLASTIC', benefit: 'Gain 1 market, then gain 1 VP for each market in your capital city.', benefitDetails: { gainBuilding: 'Market' } },
                    { number: 9, name: 'ELECTRONICS', benefit: 'In any order, upgrade 1 tech card and gain the circle benefit of 1 tech card in your middle row.', benefitDetails: {} },
                    { number: 10, name: 'COMPUTERS', benefit: 'Gain 1 VP per military and science track space you’ve advanced. [LANDMARK: Tech Hub]', benefitDetails: {} },
                    { number: 11, name: 'NANOTECHNOLOGY', benefit: 'In any order, upgrade 1 tech card & gain the square benefit of 1 tech card in your top row. [BONUS: Spend 3 tech cards. Gain 10 VP.]', benefitDetails: {} },
                    { number: 12, name: 'AI SINGULARITY', benefit: 'Remove your player token from the technology track and place it on the starting space of any track. Gain 1 of each resource. This track still counts as complete. Note: if cube was removed from last space there will be a transparent cube as an indication of the max position on that track. This ability cannot be used in the 5th income phase.', benefitDetails: {} },
                ]
            },
            Science: {
                name: 'Science',
                tiers: [0, 4, 7, 10],
                landmarks: [
                    { space: 4, name: 'Apothecary' },
                    { space: 7, name: 'Academy' },
                    { space: 10, name: 'Laboratory' },
                ],
                 // Corrected cost function based on user's feedback (Tier IV costs 2)
                cost: (space) => {
                    if (space < 4) return 1; // Tier I (spaces 1-3) cost 1 to enter
                    if (space < 7) return 2; // Tier II (spaces 4-6) cost 2 to enter
                    if (space < 10) return 3; // Tier III (spaces 7-9) cost 3 to enter
                    // Tier IV (spaces 10-12) cost 2 to enter based on user feedback
                    if (space >= 10 && space <= 12) return 2;
                    return 1; // Default for space 0 (cost to move to space 1)
                },
                 spacesData: [
                    { number: 0, name: 'Start', benefit: 'Starting Space', benefitDetails: {} },
                    { number: 1, name: 'ASTRONOMY', benefit: 'Research: Roll the science die to advance for free (don’t gain benefit & bonus).', benefitDetails: {} },
                    { number: 2, name: 'MATHEMATICS', benefit: 'Gain 1 tapestry card. [BONUS: Spend 1 resource. Gain 1 house.]', benefitDetails: { gainBuilding: 'House' } },
                    { number: 3, name: 'HERBALISM', benefit: 'Research (don’t gain benefit & bonus) OR gain 1 house.', benefitDetails: { gainBuilding: 'House' } },
                    { number: 4, name: 'MEDICINE', benefit: 'Gain 1 VP for each tech card in your supply; also gain 1 tapestry card. [LANDMARK: Apothecary]', benefitDetails: {} },
                    { number: 5, name: 'CHEMISTRY', benefit: 'Research to gain the benefit & pay to gain the bonus (if any). [BONUS: Spend 2 Tapestry cards. Gain 5 VP.]', benefitDetails: {} },
                    { number: 6, name: 'BIOLOGY', benefit: 'Research to gain the benefit & pay to gain the bonus (if any) OR gain 1 house.', benefitDetails: { gainBuilding: 'House' } },
                    { number: 7, name: 'ACADEMIC RESEARCH', benefit: 'Gain the benefit & you may pay to gain the bonus (if any) of your current position on any advancement track. [LANDMARK: Academy]', benefitDetails: {} },
                    { number: 8, name: 'NUTRITION', benefit: 'Gain 1 house, then gain 1 VP for each house in your capital city.', benefitDetails: { gainBuilding: 'House' } },
                    { number: 9, name: 'PHYSICS', benefit: 'Advance on 1 of these tracks (Science or Military). Gain the benefit. You may pay to gain the bonus.', benefitDetails: {} },
                    { number: 10, name: 'NEUROSCIENCE', benefit: 'Regress on 1 of these tracks (Science or Military). Gain the benefit. You may pay to gain the bonus. [LANDMARK: Laboratory]', benefitDetails: {} },
                    { number: 11, name: 'QUANTUM PHYSICS', benefit: 'Advance on 1 of these tracks (Science or Military). Gain the benefit. You may pay to gain the bonus. Then do it again (same or different track).', benefitDetails: {} },
                    { number: 12, name: 'ARTIFICIAL INTELLIGENCE', benefit: 'Roll 4 science dice to advance (don’t gain the benefits & bonuses). Gain 5 VP per die that would push you off a track.', benefitDetails: {} },
                ]
            },
            Military: {
                name: 'Military',
                tiers: [0, 4, 7, 10],
                landmarks: [
                    // Added missing 'track' property
                    { space: 4, name: 'Barracks', track: 'Military' },
                    { space: 7, name: 'Tank Factory', track: 'Military' },
                    { space: 10, name: 'Fusion Reactor', track: 'Military' },
                ],
                 // Corrected cost function based on user's feedback (Tier IV costs 2)
                cost: (space) => {
                    if (space < 4) return 1; // Tier I (spaces 1-3) cost 1 to enter
                    if (space < 7) return 2; // Tier II (spaces 4-6) cost 2 to enter
                    if (space < 10) return 3; // Tier III (spaces 7-9) cost 3 to enter
                    // Tier IV (spaces 10-12) cost 2 to enter based on user feedback
                    if (space >= 10 && space <= 12) return 2;
                    return 1; // Default for space 0 (cost to move to space 1)
                },
                 spacesData: [
                    { number: 0, name: 'Start', benefit: 'Starting Space', benefitDetails: {} },
                    { number: 1, name: 'ARCHERY', benefit: 'Conquer: Place an outpost on a territory adjacent to a territory you control. Roll the 2 conquer dice and pick 1 of the benefits rolled.', benefitDetails: {} },
                    { number: 2, name: 'BLADED WEAPONS', benefit: 'Gain 1 tapestry card. [BONUS: Spend 1 resource. Gain 1 armory.]', benefitDetails: { gainBuilding: 'Armory' } },
                    { number: 3, name: 'WALLS', benefit: 'Conquer 1 territory OR gain 1 armory.', benefitDetails: { gainBuilding: 'Armory' } },
                    { number: 4, name: 'STANDING ARMY', benefit: 'Gain 1 worker and gain 1 VP per territory tile in your supply. [LANDMARK: Barracks]', benefitDetails: {} },
                    { number: 5, name: 'CAVALRY', benefit: 'Conquer 1 territory and gain 1 armory.', benefitDetails: { gainBuilding: 'Armory' } },
                    { number: 6, name: 'GUNPOWDER', benefit: 'Conquer 1 territory and gain 1 tapestry card. [BONUS: Spend 1 resource. Gain 1 armory.]', benefitDetails: { gainBuilding: 'Armory' } },
                    { number: 7, name: 'TANKS', benefit: 'Conquer 1 territory. If that territory was controlled by an opponent, gain the benefits of both conquer dice. [LANDMARK: Tank Factory]', benefitDetails: {} },
                    { number: 8, name: 'WARPLANES', benefit: 'Conquer 1 territory anywhere on the map. [BONUS: Spend 1 resource. Gain 1 tapestry card.]', benefitDetails: {} },
                    { number: 9, name: 'ANTI-AIRCRAFT DEFENSE', benefit: 'Gain 1 armory and gain 1 VP per tapestry card (in hand and on your income mat). Rulings: Covered tapestries also count', benefitDetails: { gainBuilding: 'Armory' } },
                    { number: 10, name: 'NUCLEAR BOMB', benefit: 'Gain 1 VP per exploration track space you’ve advanced. Also play a tapestry on top of your current tapestry. Only the new card is active. [LANDMARK: Fusion Reactor]. Rulings: Tapestry overplay is void if this is activated during 5th income, or during income before era tapestry is played or if player has no tapestry card in hand.', benefitDetails: {} },
                    { number: 11, name: 'DRONE ASSASSINS', benefit: 'Score your capital city. [BONUS: Spend 3 Tapestry cards. Gain 10 VP.]', benefitDetails: {} },
                    { number: 12, name: 'MECHS', benefit: 'Conquer 1 territory (gain the benefits of both conquer dice). Also gain a random additional civilization.', benefitDetails: {} },
                ]
            },
            Arts: {
                name: 'Arts',
                tiers: [0, 4, 7, 10],
                landmarks: [
                    // Added missing 'track' property
                    { space: 4, name: 'Clock Tower', track: 'Arts' },
                    { space: 7, name: 'Opera House', track: 'Arts' }, // Corrected name from PDF based on allLandmarksCategorized
                    { space: 10, name: 'Holocenter', track: 'Arts' }, // Using name from PDF based on allLandmarksCategorized
                ],
                 // Corrected cost function based on user's feedback (Tier IV costs 2)
                cost: (space) => {
                    if (space < 4) return 1; // Tier I (spaces 1-3) cost 1 to enter
                    if (space < 7) return 2; // Tier II (spaces 4-6) cost 2 to enter
                    if (space < 10) return 3; // Tier III (spaces 7-9) cost 3 to enter
                    // Tier IV (spaces 10-12) cost 2 to enter based on user feedback
                    if (space >= 10 && space <= 12) return 2;
                    return 1; // Default for space 0 (cost to move to space 1)
                },
                 spacesData: [
                    { number: 0, name: 'Start', benefit: 'Starting Space', benefitDetails: {} },
                    { number: 1, name: 'CAVE PAINTINGS', benefit: 'Gain 1 tapestry card.', benefitDetails: {} },
                    { number: 2, name: 'FLUTES', benefit: 'Gain 5 VP. [BONUS: Spend 1 resource. Gain 1 income building of any type.]', benefitDetails: { gainBuildingChoice: ['Market', 'House', 'Farm', 'Armory'] } },
                    { number: 3, name: 'DANCE', benefit: 'Create: Gain a masterpiece card (always choose from 1 of the 3 face-up cards or the top card of the deck.)', benefitDetails: {} },
                    { number: 4, name: 'EPIC POETRY', benefit: 'Gain 1 VP per territory tile in your supply and gain 1 VP per tech card in your supply. [LANDMARK: Clock Tower]', benefitDetails: {} },
                    { number: 5, name: 'SYMPHONY', benefit: 'Inspire: Place an inspiration tile on your income mat, covering the relevant income track. [BONUS: Spend 1 resource. Create a masterpiece card.]', benefitDetails: {} },
                    { number: 6, name: 'CARVED MARBLE SCULPTURE', benefit: 'Broadcast: Gain the benefit of 1 of your masterpiece cards; or gain 1 income building of any type.', benefitDetails: { gainBuildingChoice: ['Market', 'House', 'Farm', 'Armory'] } },
                    { number: 7, name: 'ROCK OPERA', benefit: 'You may discard all revealed cards next to the masterpiece deck, then replace them from the deck. Lastly, create a masterpiece card. [LANDMARK: Opera House]', benefitDetails: {} }, // Corrected landmark name
                    { number: 8, name: 'CGI ANIMATION', benefit: 'Inspire an inspiration tile. [BONUS: Spend 1 resource. Gain 1 income building of any type.]', benefitDetails: { gainBuildingChoice: ['Market', 'House', 'Farm', 'Armory'] } },
                    { number: 9, name: 'FLASH MOB', benefit: 'Advance on 1 of these tracks (Military, Technology, Exploration, or Science). Gain the benefit. You may pay to gain the bonus.', benefitDetails: {} },
                    { number: 10, name: 'VIRTUAL REALITY HOLOCENTER', benefit: 'Gain 1 income building of any type. Gain 1 VP for each of your income buildings. [LANDMARK: Holocenter]', benefitDetails: { gainBuildingChoice: ['Market', 'House', 'Farm', 'Armory'] } }, // Corrected landmark name
                    { number: 11, name: 'INFINITE SPECTRUM PHOTOGRAPHY', benefit: 'Advance on 1 of these tracks (Military, Technology, Exploration, or Science). Gain the benefit. You may pay to gain the bonus. [BONUS: Spend 1 resource. Create a masterpiece card.]', benefitDetails: {} },
                    { number: 12, name: 'STREAMING IMPLANTS', benefit: 'Gain the benefit of up to 3 different masterpiece cards (yours or your neighbors\').', benefitDetails: {} },
                ]
            },
        };

        // Comprehensive list of all landmarks, categorized by location/source from PDF
        // Used to initialize the landmarks state and the Landmark Status Control section
        const allLandmarksCategorized = {
            'Exploration Track': [
                 { name: 'Lighthouse', track: 'Exploration', space: 4 },
                 { name: 'Train Station', track: 'Exploration', space: 7 },
                 { name: 'Launch Pad', track: 'Exploration', space: 10 },
            ],
             'Technology Track': [
                 { name: 'Forge', track: 'Technology', space: 4 },
                 { name: 'Rubber Factory', track: 'Technology', space: 7 }, // Corrected name from PDF based on allLandmarksCategorized
                 { space: 10, name: 'Tech Hub', track: 'Technology' }, // Added missing 'track' property
             ],
            'Science Track': [
                { name: 'Apothecary', track: 'Science', space: 4 },
                { name: 'Academy', track: 'Science', space: 7 },
                { space: 10, name: 'Laboratory', track: 'Science' }, // Added missing 'track' property
            ],
            'Military Track': [
                // Added missing 'track' property to each landmark
                { space: 4, name: 'Barracks', track: 'Military' },
                { space: 7, name: 'Tank Factory', track: 'Military' },
                { space: 10, name: 'Fusion Reactor', track: 'Military' },
            ],
             'Arts Track': [
                // Added missing 'track' property to each landmark
                { space: 4, name: 'Clock Tower', track: 'Arts' },
                { space: 7, name: 'Opera House', track: 'Arts' }, // Corrected name from PDF based on allLandmarksCategorized
                { space: 10, name: 'Holocenter', track: 'Arts' }, // Using name from PDF based on allLandmarksCategorized
             ],
            'Tech Card': [
                { name: 'Bakery' },
                { name: 'Barn' },
                { name: 'Com Tower' },
                { name: 'Library' },
                { name: 'Stock Market' },
                { name: 'Treasury' },
            ],
            // Combined category for Landmark Cards, Space Tiles, and Tapestry Cards
            'Cards & Tiles': [
                { name: 'Digital Studio' },
                { name: 'Game Store' },
                { name: 'Skyscraper' },
                { name: 'TV Station' },
                { name: 'Urban Farm' },
                { name: 'Birdwatching Perch' },
                { name: 'Bridge' },
                { name: 'Castle' },
                { name: 'Villa' },
                { name: 'Windmill' },
                { name: 'Monolith' },
                { name: 'Stadium' },
            ],
        };


        // Helper to get the current Tier number based on space
        const getTier = (space) => {
            if (space >= 1 && space <= 3) return 1;
            if (space >= 4 && space <= 6) return 2;
            if (space >= 7 && space <= 9) return 3;
            if (space >= 10 && space <= 12) return 4;
            return 0; // Space 0 doesn't have a Tier marker
        };

        // Function to generate all permutations of an array
        const generatePermutations = (arr) => {
            if (arr.length <= 1) {
                return [arr];
            }

            const result = [];
            for (let i = 0; i < arr.length; i++) {
                const firstElement = arr[i];
                const remainingElements = arr.slice(0, i).concat(arr.slice(i + 1));
                const subPermutations = generatePermutations(remainingElements);
                for (let j = 0; j < subPermutations.length; j++) {
                    result.push([firstElement].concat(subPermutations[j]));
                }
            }
            return result;
        };

        // Generate all 120 permutations of the tracks once
        const allTrackPermutations = generatePermutations(Object.keys(tracksData));

         // Helper function to check if a track meets a specific priority rule and is affordable
         const meetsPriorityRuleAndAffordable = (automaPos, playerPos, trackName, rule, landmarksState, resources, tracksData) => {
             const nextSpace = automaPos[trackName] + 1;
             // Cannot advance if already at the end of the track (space 12)
             if (automaPos[trackName] >= 12) {
                 return false;
             }
             const costToAdvance = tracksData[trackName].cost(nextSpace);

             // Rule 1: Advance on a Tier IV space (spaces 10, 11, 12)
             if (rule === 1) {
                 return nextSpace >= 10 && nextSpace <= 12 && resources >= costToAdvance;
             }
             // Rule 2: Automa is tied with the player
             if (rule === 2) {
                 return automaPos[trackName] === playerPos[trackName] && resources >= costToAdvance;
             }
             // Rule 3: Automa is 1 space away from a landmark it hasn't claimed
             if (rule === 3) {
                 const trackLandmarks = tracksData[trackName].landmarks;
                 return trackLandmarks.some(landmark =>
                     landmark.space === nextSpace && landmarksState[`${trackName}-${landmark.space}`]?.status === 'available' && resources >= costToAdvance
                 );
             }
             // Rule 4: Any affordable advance (space > 0)
             if (rule === 4) {
                 return nextSpace > 0 && resources >= costToAdvance;
             }
             // Rule 5: Advance from space 0 (must be on space 0 currently)
             if (rule === 5) {
                 return automaPos[trackName] === 0 && nextSpace === 1 && resources >= costToAdvance;
             }
             // Rule 6 (Aggressive): Automa is ahead of the player
             if (rule === 6) {
                 return automaPos[trackName] > playerPos[trackName] && resources >= costToAdvance;
             }
             // Rule 7 (Strategic): Advance to an available landmark space
             if (rule === 7) {
                 const trackLandmarks = tracksData[trackName].landmarks;
                 return trackLandmarks.some(landmark =>
                     landmark.space === nextSpace && landmarksState[`${trackName}-${landmark.space}`]?.status === 'available' && resources >= costToAdvance
                 );
             }
             // Rule 8 (Peaceful): Advance on a track that provides a building (non-military)
             if (rule === 8) {
                 const spaceData = tracksData[trackName].spacesData.find(s => s.number === nextSpace);
                 return trackName !== 'Military' && spaceData?.benefitDetails?.gainBuilding && resources >= costToAdvance;
             }
              // Rule 9 (Revengeful): Player is ahead of Automa
             if (rule === 9) {
                 return playerPos[trackName] > automaPos[trackName] && resources >= costToAdvance;
             }
             // Rule 10 (Revengeful): Player has claimed a landmark on this track that Automa hasn't
             if (rule === 10) {
                 const trackLandmarks = tracksData[trackName].landmarks;
                 return trackLandmarks.some(landmark =>
                     landmark.space <= automaPos[trackName] && // Check landmarks Automa has passed or is on
                     landmarksState[`${trackName}-${landmark.space}`]?.status === 'player' && // Player claimed it
                     resources >= costToAdvance // Still needs to be affordable to advance
                 );
             }


             return false; // Default case
         };

         // Helper function to check if a track meets a specific priority rule and is affordable, excluding space 0 unless the rule is 5
         const meetsPriorityRuleAndAffordableAboveZero = (automaPos, playerPos, trackName, rule, landmarksState, resources, tracksData) => {
             // If the rule is 5 (from space 0), use the standard check
             if (rule === 5) {
                 return meetsPriorityRuleAndAffordable(automaPos, playerPos, trackName, rule, landmarksState, resources, tracksData);
             }
             // For all other rules, check if the next space is > 0
             const nextSpace = automaPos[trackName] + 1;
             if (nextSpace <= 0) {
                 return false;
             }
             return meetsPriorityRuleAndAffordable(automaPos, playerPos, trackName, rule, landmarksState, resources, tracksData);
         };


         // Helper function to draw a new permutation and potentially reorder based on character
         const drawNewPermutation = (availablePerms, selectedCharacter, tracksData, gameState) => {
             if (availablePerms.length === 0) {
                 console.warn("No available permutations left!");
                 // Handle this case - maybe reshuffle all permutations? For now, return a default.
                 return Object.keys(tracksData); // Return default order if none left
             }

             // Draw a random permutation
             const randomIndex = Math.floor(Math.random() * availablePerms.length);
             let newPermutation = [...availablePerms[randomIndex]]; // Create a copy

             console.log(`Drawn permutation: ${newPermutation.join(' > ')}`);

             // Reorder based on character
             if (selectedCharacter === 'Strategic') {
                 // Strategic: Prioritize tracks where Automa is closest to an unclaimed landmark
                 newPermutation.sort((a, b) => {
                     const distA = getDistanceToClosestUnclaimedLandmark(gameState.automaPositions[a], tracksData[a].landmarks, gameState.landmarks, a);
                     const distB = getDistanceToClosestUnclaimedLandmark(gameState.automaPositions[b], tracksData[b].landmarks, gameState.landmarks, b);
                     // Sort by shortest distance first
                     return distA - distB;
                 });
                 console.log(`Strategic reorder: ${newPermutation.join(' > ')}`);

             } else if (selectedCharacter === 'Revengeful') { // Corrected spelling
                 // Revengful: Prioritize tracks where the player is furthest ahead of Automa
                 newPermutation.sort((a, b) => {
                     const diffA = gameState.playerPositions[a] - gameState.automaPositions[a];
                     const diffB = gameState.playerPositions[b] - gameState.automaPositions[b];
                     // Sort by largest difference (player furthest ahead) first
                     return diffB - diffA;
                 });
                 console.log(`Revengful reorder: ${newPermutation.join(' > ')}`);
             }

             return newPermutation;
         };

         // Helper function to get the distance to the closest unclaimed landmark on a track
         const getDistanceToClosestUnclaimedLandmark = (currentPos, landmarks, landmarksState, trackName) => {
             let minDistance = Infinity;
             landmarks.forEach(landmark => {
                 const landmarkKey = `${trackName}-${landmark.space}`;
                 if (landmarksState[landmarkKey]?.status === 'available') {
                     const distance = landmark.space - currentPos;
                     if (distance > 0 && distance < minDistance) {
                         minDistance = distance;
                     }
                 }
             });
             return minDistance === Infinity ? 100 : minDistance; // Return a large number if no unclaimed landmarks ahead
         };


        // Helper function to check and claim landmarks (automated for crossing space)
        // This function modifies the state object passed to it directly
         const checkLandmarks = (state, trackName, oldPos, newPos, playerType) => {
             const trackLandmarks = tracksData[trackName].landmarks;
             let claimed = false;
             trackLandmarks.forEach(landmarkInfo => {
                 const landmarkSpace = landmarkInfo.space;
                 // Check if the move crossed this landmark space *and* the landmark is available
                 // Handles both single-step and jump moves
                 if (oldPos < landmarkSpace && newPos >= landmarkSpace) {
                     // Construct the correct key for track landmarks
                     const landmarkKey = `${trackName}-${landmarkSpace}`;
                     // Check if the landmark exists in the state and is available
                     if (state.landmarks[landmarkKey]) { // Check if landmark exists
                          if (state.landmarks[landmarkKey].status === 'available') {
                              state.landmarks[landmarkKey].status = playerType; // Claim the landmark for the player type
                              claimed = true;
                          }
                     } else {
                         console.warn(`Landmark key ${landmarkKey} not found in state during checkLandmarks.`);
                     }
                 }
             });
             return claimed;
         };


        // Calculate Automa's next move based on priority rules and character
        // Added availablePerms as a parameter
        const calculateAutomaMove = (currentState, availablePerms, selectedCharacter) => { // Added availablePerms parameter
            console.log("--- Calculating Automa Move ---");
            console.log("Current State:", {
                automaPositions: currentState.automaPositions,
                automaResources: currentState.automaResources,
                currentTiebreakerTrack: currentState.currentTiebreakerTrack,
                automaCharacter: selectedCharacter
            });

            // Log Automa positions at the very start of the calculation
            console.log("Automa Positions at start of calculateAutomaMove:", currentState.automaPositions);


            const currentAutomaPos = currentState.automaPositions;
            const currentPlayerPos = currentState.playerPositions;
            const currentResources = currentState.automaResources;
            const tracks = Object.keys(tracksData);
            const landmarksState = currentState.landmarks;

            // Add explicit check for NaN in automaPositions
            tracks.forEach(trackName => {
                if (isNaN(currentAutomaPos[trackName])) {
                    console.error(`Automa position for ${trackName} is NaN! Value: ${currentAutomaPos[trackName]}`);
                }
            });


            let candidateTracks = []; // Array to hold tracks that meet the highest priority rule OR are affordable for Rule 4/5
            let triggeredPriorityRule = null; // To store the highest priority rule triggered
            let usedSpecialLogic = false; // Flag to indicate if the 15% logic was attempted

            // Helper to check if a track meets a specific rule and is affordable
            const isAffordableAndMeetsRule = (trackName, rule) => {
                 // Check if Automa is already at the end of the track
                 if (currentAutomaPos[trackName] >= 12) {
                     return false;
                 }
                 // FIX: Use the local currentAutomaPos variable instead of re-accessing automaPos[trackName]
                 const nextSpace = currentAutomaPos[trackName] + 1; // This line is correct here as it's accessing the object passed in
                 const costToAdvance = tracksData[trackName].cost(nextSpace);

                 if (currentResources < costToAdvance) {
                     return false; // Not affordable
                 }
                 // Check if it meets the specific rule
                 return meetsPriorityRuleAndAffordable(currentAutomaPos, currentPlayerPos, trackName, rule, landmarksState, currentResources, tracksData);
            };

            // --- 15% Chance for Special Logic ---
            const randomChance = Math.random();
            if (randomChance < 0.15) {
                usedSpecialLogic = true;
                console.log("Attempting 15% special move logic...");

                let specialCandidateTracks = [];

                // 1. Track where Automa is most advanced
                let mostAdvancedPos = -1;
                let mostAdvancedTracks = [];
                tracks.forEach(trackName => {
                    if (currentAutomaPos[trackName] > mostAdvancedPos) {
                        mostAdvancedPos = currentAutomaPos[trackName];
                        mostAdvancedTracks = [trackName];
                    } else if (currentAutomaPos[trackName] === mostAdvancedPos) {
                        mostAdvancedTracks.push(trackName);
                    }
                });
                // Add affordable most advanced tracks to candidates (only if not at the end)
                mostAdvancedTracks.forEach(trackName => {
                     if (currentAutomaPos[trackName] < 12 && tracksData[trackName].cost(currentAutomaPos[trackName] + 1) <= currentResources) {
                         specialCandidateTracks.push({ track: trackName, type: 'mostAdvanced' });
                     }
                });


                // 2. Track where Automa is least advanced
                let leastAdvancedPos = 13; // Higher than any possible space
                let leastAdvancedTracks = [];
                 tracks.forEach(trackName => {
                     if (currentAutomaPos[trackName] < leastAdvancedPos) {
                         leastAdvancedPos = currentAutomaPos[trackName];
                         leastAdvancedTracks = [trackName];
                     } else if (currentAutomaPos[trackName] === leastAdvancedPos) {
                         leastAdvancedTracks.push(trackName);
                     }
                 });
                // Add affordable least advanced tracks to candidates (only if not at the end)
                leastAdvancedTracks.forEach(trackName => {
                     if (currentAutomaPos[trackName] < 12 && tracksData[trackName].cost(currentAutomaPos[trackName] + 1) <= currentResources) {
                         specialCandidateTracks.push({ track: trackName, type: 'leastAdvanced' });
                     }
                });


                // 3. Track where Automa is 1 space behind the player
                let oneSpaceBehindTracks = [];
                tracks.forEach(trackName => {
                    if (currentAutomaPos[trackName] === currentPlayerPos[trackName] - 1) {
                        // Check if advancing on this track is possible and affordable
                         if (currentAutomaPos[trackName] < 12 && tracksData[trackName].cost(currentAutomaPos[trackName] + 1) <= currentResources) {
                            oneSpaceBehindTracks.push({ track: trackName, type: 'oneSpaceBehind' });
                         }
                    }
                });
                 // Add affordable one space behind tracks to candidates
                 specialCandidateTracks = specialCandidateTracks.concat(oneSpaceBehindTracks);


                // Remove duplicate tracks from specialCandidateTracks while keeping track type
                const uniqueSpecialCandidateTracks = [];
                const trackNamesSeen = new Set();
                specialCandidateTracks.forEach(candidate => {
                     if (!trackNamesSeen.has(candidate.track)) {
                          uniqueSpecialCandidateTracks.push(candidate);
                          trackNamesSeen.add(candidate.track);
                     }
                });
                specialCandidateTracks = uniqueSpecialCandidateTracks;


                console.log("Special candidate tracks:", specialCandidateTracks);


                if (specialCandidateTracks.length > 0) {
                    // Randomly choose one track from the special candidates
                    const chosenCandidate = specialCandidateTracks[Math.floor(Math.random() * specialCandidateTracks.length)];
                    const trackToAdvance = chosenCandidate.track;
                    const targetSpace = currentAutomaPos[trackToAdvance] + 1;
                    const cost = tracksData[trackToAdvance].cost(targetSpace);

                    let reasonDescription = `Special Logic (${chosenCandidate.type})`;

                     let details = `[${selectedCharacter}] Advanced on ${trackToAdvance} track to space ${targetSpace}, spent ${cost} resources. Reason: ${reasonDescription}.`;

                     // Special logic doesn't use the standard tiebreaker, but we can note if there were multiple special candidates
                     if (specialCandidateTracks.length > 1) {
                         details += ` (Chosen from ${specialCandidateTracks.length} special options).`;
                     }

                    console.log("Automa Special Advance Move:", {
                        action: 'advance',
                        track: trackToAdvance,
                        space: targetSpace,
                        cost: cost,
                        priorityRule: 'Special', // Use a distinct rule identifier
                        permutation: null, // No permutation used for this logic
                        details: details,
                        candidateTracks: [trackToAdvance] // Only the chosen track is the candidate for execution
                    });

                     // Return the move based on special logic
                     return {
                         action: 'advance',
                         track: trackToAdvance,
                         space: targetSpace,
                         cost: cost,
                         priorityRule: 'Special',
                         permutation: null,
                         details: details,
                         candidateTracks: [trackToAdvance]
                     };

                } else {
                    console.log("No valid tracks found with 15% special logic. Falling back to standard logic.");
                    // If no valid track found with special logic, fall through to standard logic
                     // Add a note to the message that the special attempt failed
                     currentState.automaTurnMessage = `[${selectedCharacter}] 15% special logic attempt failed (no valid/affordable tracks). Falling back to standard logic.`;
                }
            }

            // --- Standard 85% Logic (or fallback from 15% logic) ---
             console.log("Using standard 85% logic...");
             // If special logic wasn't used, or failed, proceed with the standard logic
            switch (selectedCharacter) {
                case 'Normal':
                    // Normal Automa Logic (Rules 1, 2, 3, 5, 4)
                    const normalPriorityOrder = [1, 2, 3]; // Tier IV, Tied, Landmark Approaching
                    for (const priority of normalPriorityOrder) {
                         let tracksMeetingThisPriority = tracks.filter(trackName =>
                             meetsPriorityRuleAndAffordableAboveZero(currentAutomaPos, currentPlayerPos, trackName, priority, landmarksState, currentResources, tracksData)
                         );
                         if (tracksMeetingThisPriority.length > 0) {
                              candidateTracks = tracksMeetingThisPriority;
                              triggeredPriorityRule = priority;
                              break;
                         }
                    }

                    if (candidateTracks.length === 0) {
                         // Check Rule 5 (Start from Space 0) - ONLY check tracks where Automa is currently on space 0
                         let tracksOnSpaceZero = tracks.filter(trackName => currentAutomaPos[trackName] === 0 && isAffordableAndMeetsRule(trackName, 5));
                         if (tracksOnSpaceZero.length > 0) {
                             candidateTracks = tracksOnSpaceZero;
                             triggeredPriorityRule = 5;
                         } else {
                              // Check Rule 4 (Any Affordable > 0)
                              let affordableTracksAboveZero = tracks.filter(trackName => isAffordableAndMeetsRule(trackName, 4));
                              if (affordableTracksAboveZero.length > 0) {
                                   candidateTracks = affordableTracksAboveZero;
                                   triggeredPriorityRule = 4;
                               } else {
                                    return { action: 'income', details: `[${selectedCharacter}] No affordable advance possible. Automa takes an Income Turn.` };
                               }
                         }
                    }
                    break;

                case 'Aggressive':
                    // Aggressive Automa Logic (Rules 1, 6, 1, 3, 4, 5) - Note: Aggressive Rule 1 (Military) is different from Normal Rule 1 (Tier IV)
                    const aggressivePriorityOrder = [
                         { rule: 1, check: (track) => track === 'Military' && isAffordableAndMeetsRule(track, 1) }, // Aggressive Rule 1: Military Advance
                         { rule: 6, check: (track) => isAffordableAndMeetsRule(track, 6) }, // Aggressive Rule 2: Ahead of Player
                         { rule: 1, check: (track) => isAffordableAndMeetsRule(track, 1) }, // Aggressive Rule 3: Tier IV (Normal Rule 1)
                         { rule: 3, check: (track) => isAffordableAndMeetsRule(track, 3) }, // Aggressive Rule 4: Landmark Approaching (Normal Rule 3)
                         { rule: 4, check: (track) => isAffordableAndMeetsRule(track, 4) }, // Aggressive Rule 5: Any Affordable > 0 (Normal Rule 4)
                         { rule: 5, check: (track) => currentAutomaPos[track] === 0 && isAffordableAndMeetsRule(track, 5) }, // Aggressive Rule 6: From Space 0 (Normal Rule 5) - Added check for current position
                    ];

                     for (const priority of aggressivePriorityOrder) {
                         let tracksMeetingThisPriority = tracks.filter(trackName => priority.check(trackName));
                         if (tracksMeetingThisPriority.length > 0) {
                              candidateTracks = tracksMeetingThisPriority;
                              triggeredPriorityRule = priority.rule; // Store the corresponding rule number
                              break;
                         }
                     }

                     if (candidateTracks.length === 0) {
                         return { action: 'income', details: `[${selectedCharacter}] No affordable advance possible. Automa takes an Income Turn.` };
                     }
                    break;

                case 'Strategic':
                    // Strategic Automa Logic (Rules 7, 6, 1, 3, 4, 5)
                    const strategicPriorityOrder = [
                         { rule: 7, check: (track) => isAffordableAndMeetsRule(track, 7) }, // Strategic Rule 1: Available Landmark
                         { rule: 6, check: (track) => isAffordableAndMeetsRule(track, 6) }, // Strategic Rule 2: Ahead of Player
                         { rule: 1, check: (track) => isAffordableAndMeetsRule(track, 1) }, // Strategic Rule 3: Tier IV (Normal Rule 1)
                         { rule: 3, check: (track) => isAffordableAndMeetsRule(track, 3) }, // Strategic Rule 4: Landmark Approaching (Normal Rule 3)
                         { rule: 4, check: (track) => isAffordableAndMeetsRule(track, 4) }, // Strategic Rule 5: Any Affordable > 0 (Normal Rule 4)
                         { rule: 5, check: (track) => currentAutomaPos[track] === 0 && isAffordableAndMeetsRule(track, 5) }, // Strategic Rule 6: From Space 0 (Normal Rule 5) - Added check for current position
                    ];

                     for (const priority of strategicPriorityOrder) {
                         let tracksMeetingThisPriority = tracks.filter(trackName => priority.check(trackName));
                         if (tracksMeetingThisPriority.length > 0) {
                              candidateTracks = tracksMeetingThisPriority;
                              triggeredPriorityRule = priority.rule;
                              break;
                         }
                     }

                     if (candidateTracks.length === 0) {
                         return { action: 'income', details: `[${selectedCharacter}] No affordable advance possible. Automa takes an Income Turn.` };
                     }
                    break;

                case 'Peaceful':
                    // Peaceful Automa Logic (Rules 8, 1, 3, 4, 5) - Excludes Military where possible
                    const peacefulPriorityOrder = [
                         { rule: 8, check: (track) => track !== 'Military' && isAffordableAndMeetsRule(track, 8) }, // Peaceful Rule 1: Building Gain (Non-Military)
                         { rule: 1, check: (track) => track !== 'Military' && isAffordableAndMeetsRule(track, 1) }, // Peaceful Rule 2: Tier IV (Non-Military)
                         { rule: 3, check: (track) => track !== 'Military' && isAffordableAndMeetsRule(track, 3) }, // Peaceful Rule 3: Landmark Approaching (Non-Military)
                         { rule: 4, check: (track) => track !== 'Military' && isAffordableAndMeetsRule(track, 4) }, // Peaceful Rule 4: Any Affordable > 0 (Non-Military)
                         { rule: 5, check: (track) => currentAutomaPos[track] === 0 && track !== 'Military' && isAffordableAndMeetsRule(track, 5) }, // Peaceful Rule 5: From Space 0 (Normal Rule 5) - Added check for current position
                    ];

                     for (const priority of peacefulPriorityOrder) {
                         let tracksMeetingThisPriority = tracks.filter(trackName => priority.check(trackName));
                         if (tracksMeetingThisPriority.length > 0) {
                              candidateTracks = tracksMeetingThisPriority;
                              triggeredPriorityRule = priority.rule;
                              break;
                         }
                     }

                     // If no non-military moves, check if *only* military moves are possible (and affordable)
                     if (candidateTracks.length === 0) {
                          const militaryAffordableAboveZero = isAffordableAndMeetsRule('Military', 4);
                          const militaryAffordableFromZero = currentAutomaPos['Military'] === 0 && isAffordableAndMeetsRule('Military', 5); // Explicitly check Military from 0

                          if (militaryAffordableAboveZero) {
                               candidateTracks = ['Military'];
                               triggeredPriorityRule = 4; // Fallback to Rule 4 for Military
                          } else if (militaryAffordableFromZero) {
                               candidateTracks = ['Military'];
                               triggeredPriorityRule = 5; // Fallback to Rule 5 for Military
                          } else {
                               // No affordable moves at all (including Military)
                               return { action: 'income', details: `[${selectedCharacter}] No affordable advance possible. Automa takes an Income Turn.` };
                           }
                     }
                    break;

                case 'Revengeful': // Corrected spelling
                    // Revengful Automa Logic (Rules 9, 10, 1, 2, 3, 4, 5)
                    const revengfulPriorityOrder = [
                         { rule: 9, check: (track) => isAffordableAndMeetsRule(track, 9) }, // Revengful Rule 1: Player Ahead
                         { rule: 10, check: (track) => isAffordableAndMeetsRule(track, 10) }, // Revengful Rule 2: Player Claimed Landmark
                         { rule: 1, check: (track) => isAffordableAndMeetsRule(track, 1) }, // Revengful Rule 3: Tier IV (Normal Rule 1)
                         { rule: 2, check: (track) => isAffordableAndMeetsRule(track, 2) }, // Revengful Rule 4: Tied with Player (Normal Rule 2)
                         { rule: 3, check: (track) => isAffordableAndMeetsRule(track, 3) }, // Revengful Rule 5: Landmark Approaching (Normal Rule 3)
                         { rule: 4, check: (track) => isAffordableAndMeetsRule(track, 4) }, // Revengful Rule 6: Any Affordable > 0 (Normal Rule 4)
                         { rule: 5, check: (track) => currentAutomaPos[track] === 0 && isAffordableAndMeetsRule(track, 5) }, // Revengful Rule 7: From Space 0 (Normal Rule 5) - Added check for current position
                    ];

                     for (const priority of revengfulPriorityOrder) {
                         let tracksMeetingThisPriority = tracks.filter(trackName => priority.check(trackName));
                         if (tracksMeetingThisPriority.length > 0) {
                              candidateTracks = tracksMeetingThisPriority;
                              triggeredPriorityRule = priority.rule;
                              break;
                         }
                     }

                     if (candidateTracks.length === 0) {
                         return { action: 'income', details: `[${selectedCharacter}] No affordable advance possible. Automa takes an Income Turn.` };
                     }
                    break;

                default:
                    // Fallback to Normal logic if character is unknown or not selected
                    console.warn(`Unknown or unselected Automa character: ${selectedCharacter}. Falling back to Normal.`);
                     const defaultPriorityOrder = [1, 2, 3];
                     for (const priority of defaultPriorityOrder) {
                          let tracksMeetingThisPriority = tracks.filter(trackName =>
                              meetsPriorityRuleAndAffordableAboveZero(currentAutomaPos, currentPlayerPos, trackName, priority, landmarksState, currentResources, tracksData)
                          );
                          if (tracksMeetingThisPriority.length > 0) {
                               candidateTracks = tracksMeetingThisPriority;
                               triggeredPriorityRule = priority;
                               break;
                          }
                     }

                     if (candidateTracks.length === 0) {
                          // Check Rule 5 (Start from Space 0) - ONLY check tracks where Automa is currently on space 0
                         let tracksOnSpaceZero = tracks.filter(trackName => currentAutomaPos[trackName] === 0 && isAffordableAndMeetsRule(trackName, 5));
                          if (tracksOnSpaceZero.length > 0) {
                              candidateTracks = tracksOnSpaceZero;
                              triggeredPriorityRule = 5;
                          } else {
                               let affordableTracksAboveZero = tracks.filter(trackName => isAffordableAndMeetsRule(trackName, 4));
                               if (affordableTracksAboveZero.length > 0) {
                                    candidateTracks = affordableTracksAboveZero;
                                   triggeredPriorityRule = 4;
                               } else {
                                    return { action: 'income', details: `[Normal] No affordable advance possible. Automa takes an Income Turn.` };
                               }
                          }
                     }
                    break;
            }


            // --- Tiebreaker Logic (Applies after candidateTracks are determined) ---
            let permutationToUse = currentState.currentTiebreakerTrack;
            // Rule 4 and 5 don't clear tiebreaker on single candidate, nor does the 'Special' rule
            const isDirectAdvance = candidateTracks.length === 1 && ![4, 5, 'Special'].includes(triggeredPriorityRule);
            const isCurrentPermutationValidForCandidates = permutationToUse && Array.isArray(permutationToUse) && permutationToUse.some(track => candidateTracks.includes(track));


            if (!permutationToUse || !isCurrentPermutationValidForCandidates || isDirectAdvance) {
                 console.log("Drawing a new permutation...");
                 // Draw and potentially reorder a new permutation based on character
                 // Pass gameState to drawNewPermutation for Strategic and Revengeful logic
                 // FIX: Pass the availablePerms parameter to drawNewPermutation
                 let newPermutation = drawNewPermutation(availablePerms, selectedCharacter, tracksData, currentState); // Pass currentState
                 permutationToUse = newPermutation;
                 // Note: The state update for availablePermutations happens outside this function
                 console.log("New permutation drawn:", permutationToUse);
            } else {
                console.log("Using existing permutation:", permutationToUse);
            }

            // Log candidate tracks and the permutation before finding the track to advance
            console.log("Candidate Tracks:", candidateTracks, "Permutation to Use:", permutationToUse);


            // Find the first track in the chosen permutation that is also in the `candidateTracks`
            const trackToAdvance = permutationToUse.find(track => candidateTracks.includes(track));

            // Log the selected track to advance
            console.log("Selected trackToAdvance:", trackToAdvance);


            if (trackToAdvance) {
                // Found a track to advance on based on the tiebreaker and candidates
                const targetSpace = currentAutomaPos[trackToAdvance] + 1;
                const cost = tracksData[trackToAdvance].cost(targetSpace);

                let reasonDescription = '';
                // Provide a more descriptive reason based on the triggered rule
                 switch (triggeredPriorityRule) {
                     case 1: reasonDescription = selectedCharacter === 'Aggressive' ? 'Military Advance' : 'Tier IV'; break;
                     case 2: reasonDescription = 'Tied with Player'; break;
                     case 3: reasonDescription = 'Landmark Approaching'; break;
                     case 4: reasonDescription = 'Any Affordable (>0)'; break;
                     case 5: reasonDescription = 'Start from Space 0'; break;
                     case 6: reasonDescription = 'Ahead of Player'; break;
                     case 7: reasonDescription = 'Available Landmark'; break;
                     case 8: reasonDescription = 'Building Gain (Non-Military)'; break;
                     case 9: reasonDescription = 'Player Ahead'; break;
                     case 10: reasonDescription = 'Player Claimed Landmark'; break;
                     case 'Special': reasonDescription = `Special Logic (${details.match(/\(([^)]+)\)/)?.[1] || 'Unknown'})`; break; // Extract type from details, handle potential null
                     default: reasonDescription = 'Unknown Rule';
                 }

                 // Ensure the reason description is accurate for the actual rule triggered
                 // For Aggressive, Rule 1 is Military. For others, Rule 1 is Tier IV.
                 if (triggeredPriorityRule === 1) {
                     reasonDescription = selectedCharacter === 'Aggressive' ? 'Military Advance' : 'Tier IV';
                 }


                 let details = `[${selectedCharacter}] Advanced on ${trackToAdvance} track to space ${targetSpace}, spent ${cost} resources. Reason: ${reasonDescription}.`;

                 // Add tiebreaker info to the details if it was used for a tie or Rule 4/5 (and not Special)
                 if (!usedSpecialLogic && (candidateTracks.length > 1 || [4, 5].includes(triggeredPriorityRule))) {
                      details += ` Tiebreaker: ${permutationToUse.join(' > ')}.`;
                 }


                console.log("Automa Advance Move:", {
                    action: 'advance',
                    track: trackToAdvance,
                    space: targetSpace,
                    cost: cost,
                    priorityRule: triggeredPriorityRule,
                    permutation: permutationToUse, // Include the permutation used
                    details: details, // Use the detailed message for history
                    candidateTracks: candidateTracks // <-- Added candidateTracks here
                });


                return {
                    action: 'advance',
                    track: trackToAdvance,
                    space: targetSpace,
                    cost: cost,
                    priorityRule: triggeredPriorityRule,
                    permutation: permutationToUse, // Include the permutation used
                    details: details, // Use the detailed message for history
                    candidateTracks: candidateTracks // <-- Added candidateTracks here
                };

            } else {
                // If candidateTracks was empty, the logic should have already returned 'income'.
                // This case should only be reached if there's a logic error where candidateTracks was populated
                // but no track in the permutation matched. This is a safeguard.
                 console.warn(`Logic error: Candidate tracks available, but no track found in permutation for character ${selectedCharacter}.`);
                 return { action: 'income', details: `[${selectedCharacter}] Fallback: No track found in permutation among candidates. Automa takes an Income Turn.` };
            }
        };


        // Track Component (defined inside App now for proper scope)
        const Track = ({ name, spaces, playerPos, automaPos, landmarks, onSpaceClick, automaColor, tracksData, getTier, onAdvancePlayerOneSpace, onAdvanceAutomaOneSpaceNoBenefits, onAdvanceAutomaOneSpaceWithBenefits }) => { // Added two new handlers
            const trackData = tracksData[name];

            // Determine Automa marker color class
            const automaColorClass = automaColor ? `bg-${automaColor.toLowerCase().replace(' ', '-')}-500 border-${automaColor.toLowerCase().replace(' ', '-')}-800 border-2` : 'bg-red-300 border-red-600 border-2'; // Default to red if no color selected

             // The manual advance buttons should always be enabled unless Automa is at the end
            const canAutomaAdvance = automaPos < 12;


            return (
                <div className={`mb-8 p-4 border rounded-lg shadow-md bg-gray-100 track-${name.toLowerCase()}`}>
                    {/* Track Title and Advance Buttons */}
                    <div className="flex items-center justify-between mb-2"> {/* Use flex to align title and buttons */}
                         <h3 className="text-lg font-semibold">{name} Track</h3>
                         {/* Buttons to advance player/automa 1 space - Hidden on mobile, visible on md and up */}
                         {/* Added 'hidden md:flex' classes */}
                         <div className="hidden md:flex flex-col space-y-2 md:flex-row md:space-y-0 md:space-x-2"> {/* Stack vertically on small screens, horizontally on medium+ */}
                              <button
                                  className="px-2 py-1 rounded font-bold bg-green-500 hover:bg-green-700 text-white text-xs disabled:bg-gray-400 disabled:cursor-not-allowed" // Smaller size and text
                                  onClick={() => onAdvancePlayerOneSpace(name)} // Use passed handler
                                  disabled={playerPos >= 12} // Disable if player is at the end
                              >
                                  +1 space Player
                              </button>
                               {/* Automa Advance Button (No Benefits) */}
                              <button
                                  className={`px-2 py-1 rounded font-bold text-white text-xs disabled:bg-gray-400 disabled:cursor-not-allowed ${automaColor ? `automa-button-${automaColor.toLowerCase().replace(' ', '-')}` : 'automa-button-red'}`} // Smaller size and text
                                  onClick={() => onAdvanceAutomaOneSpaceNoBenefits(name)} // Call the new handler for no benefits
                                  disabled={!canAutomaAdvance} // Use the calculated canAutomaAdvance
                              >
                                  +1 space Automa (No Benefits)
                              </button>
                               {/* Automa Advance Button (Gain Benefits) */}
                               <button
                                   className={`px-2 py-1 rounded font-bold text-white text-xs disabled:bg-gray-400 disabled:cursor-not-allowed ${automaColor ? `automa-button-${automaColor.toLowerCase().replace(' ', '-')}` : 'automa-button-red'}`}
                                   onClick={() => onAdvanceAutomaOneSpaceWithBenefits(name)} // Call the new handler for gaining benefits
                                   disabled={!canAutomaAdvance} // Use the calculated canAutomaAdvance
                               >
                                   +1 space Automa (Gain Benefits)
                               </button>
                         </div>
                    </div>

                    {/* Potential issue: overflow-x-auto on this container might clip absolutely positioned tooltips */}
                    <div className="flex space-x-2 overflow-x-auto pb-2">
                        {trackData.spacesData.map((spaceData, i) => {
                            const isPlayer = playerPos === i;
                            const isAutoma = automaPos === i;
                            // Find the landmark info using the space number within the track data
                            const trackLandmarkInfo = trackData.landmarks.find(l => l.space === i);
                            // Get status from the comprehensive landmarks state using a unique key
                            // Construct the correct key for track landmarks
                            const landmarkKey = `${name}-${i}`;
                            const landmarkStatus = trackLandmarkInfo ? landmarks[landmarkKey]?.status : null;
                            const landmarkName = trackLandmarkInfo ? trackLandmarkInfo.name : null;

                            const tierNumber = getTier(i);

                            return (
                                <div
                                    key={i}
                                    className={`flex-shrink-0 w-24 h-28 flex flex-col items-center justify-center rounded-lg transition-colors duration-2s ease-in-out track-space
                                        ${i === 0 ? 'start-space' : ''} /* Style for start space */
                                        ${[4, 7, 10].includes(i) ? 'tier-start' : ''} /* Style for tier start spaces */
                                        ${isPlayer ? 'bg-green-300 border-green-600 border-2' : isAutoma ? automaColorClass : ''}
                                        hover:bg-gray-200`}
                                    onClick={() => onSpaceClick(name, i)}
                                >
                                    <span className="text-sm font-bold">{spaceData.number}</span>
                                    <span className="text-xs text-gray-700 text-center mt-1 px-1">{spaceData.name}</span>
                                     {trackLandmarkInfo && ( /* Always show landmark info container if landmark exists on space */
                                        <div className="landmark-info-container"
                                             title={`${landmarkName}: ${landmarkStatus === 'available' ? 'Available' : landmarkStatus === 'player' ? 'Claimed by Player' : landmarkStatus === 'automa' ? 'Claimed by Automa' : 'Gone'}`}
                                             >
                                             {landmarkStatus === 'available' && ( /* Show yellow icon only if available */
                                                <div className={`landmark-icon bg-yellow-500`}></div>
                                             )}
                                             <span className={`landmark-name ${landmarkStatus !== 'available' ? 'taken' : ''}`}> {/* Apply 'taken' class if not available */}
                                                {landmarkName}
                                             </span>
                                        </div>
                                    )}
                                    {isPlayer && <span className="text-xs mt-1 font-semibold">You</span>}
                                    {isAutoma && <span className="text-xs mt-1 font-semibold">Automa</span>}
                                     {i > 0 && <span className="tier-marker">Tier {tierNumber}</span>} {/* Tier Marker for spaces > 0 */}
                                     <div className="tooltip">{spaceData.benefit}</div> {/* Tooltip for benefit */}
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };


        // Automa Panel Component (defined outside App as it's a presentational component)
        const AutomaPanel = ({ buildings, automaLandmarks, automaColor, onAutomaColorChange, automaTurnMessage, tiebreakerTrack, onAdjustBuildings, onAdjustResources, automaCharacter, onAutomaCharacterChange, onAdjustPositions, isSetupComplete, automaResources }) => { // Added automaResources prop

            // Determine Automa panel color classes
            const automaPanelColorClass = automaColor ? `automa-${automaColor.toLowerCase().replace(' ', '-')}` : 'automa-red'; // Default to red

            return (
                <div className={`p-6 border rounded-lg shadow-xl mb-8 ${automaPanelColorClass}`}>
                    <h3 className="text-2xl mb-3">Automa Details</h3> {/* Changed heading */}

                     {/* Group Automa Color and Adjustment Buttons */}
                     {/* Conditionally hide this section if setup is complete */}
                     {!isSetupComplete && (
                         <div className="mb-4 flex flex-col items-start"> {/* Use flex-col and items-start for vertical stacking on the left */}
                              {/* Automa Color Selector */}
                              <div className="mb-4 flex items-center w-full"> {/* Use w-full to make it span the width for alignment */}
                                  <label htmlFor="automa-color" className="font-semibold block mr-4">Automa Color:</label> {/* Adjusted margin-right */}
                                  <select
                                      id="automa-color"
                                      value={automaColor}
                                      onChange={(e) => onAutomaColorChange(e.target.value)}
                                      className="p-2 rounded border shadow-sm text-gray-700 text-sm flex-grow" /* Use flex-grow to take available space */
                                  >
                                      <option value="Red">Red</option>
                                      <option value="Blue">Blue</option>
                                      <option value="Green">Green</option>
                                      <option value="Yellow">Yellow</option>
                                      <option value="Milky White">Milky White</option>
                                  </select>
                              </div>

                              {/* Automa Character Selector */}
                              <div className="mb-4 flex items-center w-full">
                                  <label htmlFor="automa-character" className="font-semibold block mr-4">Automa Character:</label>
                                  <select
                                      id="automa-character"
                                      value={automaCharacter}
                                      onChange={(e) => onAutomaCharacterChange(e.target.value)}
                                      className="p-2 rounded border shadow-sm text-gray-700 text-sm flex-grow"
                                  >
                                      <option value="Normal">Normal</option>
                                      <option value="Aggressive">Aggressive</option>
                                      <option value="Strategic">Strategic</option>
                                      <option value="Peaceful">Peaceful</option>
                                      <option value="Revengeful">Revengeful</option> {/* Corrected spelling */}
                                  </select>
                              </div>
                         </div>
                     )}


                     {/* Combined Adjust Buttons - Stacked Vertically */}
                     <div className="flex flex-col space-y-2 items-start w-full mb-6"> {/* Stack buttons vertically on the left, added mb-6 for space */}
                          {/* Button to open resource adjustment modal */}
                          <button
                              className="px-3 py-1 bg-gray-600 text-white font-bold rounded-lg shadow-md hover:bg-gray-700 transition-colors duration-200 text-sm w-auto" /* w-auto to not stretch */
                              onClick={onAdjustResources}
                          >
                              Adjust Resources
                          </button>
                          {/* Button to open building adjustment modal */}
                          <button
                              className="px-4 py-2 bg-gray-600 text-white font-bold rounded-lg shadow-md hover:bg-gray-700 transition-colors duration-200 text-sm w-auto" /* w-auto to not stretch */
                              onClick={onAdjustBuildings}
                          >
                              Adjust Buildings
                          </button>
                           {/* Button to open position adjustment modal */}
                          <button
                              className="px-4 py-2 bg-gray-600 text-white font-bold rounded-lg shadow-md hover:bg-gray-700 transition-colors duration-200 text-sm w-auto"
                              onClick={onAdjustPositions} // Call the new handler
                          >
                              Adjust Positions
                          </button>
                     </div>

                     {/* Automa Resources Display */}
                     <div className="mb-4">
                         <span className="font-semibold">Resources:</span>
                         <span className="ml-2 text-lg font-bold">{automaResources}</span> {/* Display resources */}
                     </div>


                     {/* Automa Claimed Landmarks */}
                     <div className="mb-4">
                         <span className="font-semibold">Claimed Landmarks:</span>
                         {automaLandmarks.length > 0 ? (
                             <ul className="list-disc list-inside ml-4 text-sm"> {/* Added text-sm for smaller list font */}
                                 {automaLandmarks.map(landmark => (
                                     <li key={landmark.key}>{landmark.name}</li>
                                 ))}
                             </ul>
                         ) : (
                             <span className="text-sm ml-2">None</span>
                         )}
                     </div>

                    {/* Automa Buildings - Displayed below Claimed Landmarks */}
                    <div className="mb-4">
                        <span className="font-semibold">Buildings:</span>
                        <div className="automa-buildings-grid">
                            {/* Market Building Display */}
                            <div className="building-item market-color">
                                <span>Market (Technology): {buildings.Market}</span> {/* Name with Track */}
                            </div>
                             {/* Farm Building Display */}
                            <div className="building-item farm-color">
                                <span>Farm (Exploration): {buildings.Farm}</span> {/* Name with Track */}
                            </div>
                             {/* House Building Display */}
                            <div className="building-item house-color">
                                <span>House (Science): {buildings.House}</span> {/* Name with Track */}
                            </div>
                             {/* Armory Building Display */}
                            <div className="building-item armory-color">
                                <span>Armory (Military): {buildings.Armory}</span> {/* Name with Track */}
                            </div>
                        </div>
                    </div>

                     {/* Automa Tiebreaker Track Display */}
                     {tiebreakerTrack && (
                         <div className="mb-4 p-3 bg-white bg-opacity-70 rounded-md text-sm">
                             <span className="font-semibold">Tiebreaker Track:</span> {tiebreakerTrack.join(' > ')}
                         </div>
                     )}

                    {automaTurnMessage && (
                         <div className="mt-4 p-3 bg-white bg-opacity-70 rounded-md text-sm italic">
                             {automaTurnMessage}
                         </div>
                    )}
                </div>
            );
        };

        // Building Adjustment Modal Component
        const BuildingAdjustmentModal = ({ buildings, onSave, onCancel }) => {
            // Local state for the modal inputs
            const [adjustedBuildings, setAdjustedBuildings] = React.useState({...buildings});

            // Handle input change for building counts
            const handleInputChange = (type, value) => {
                // Ensure value is a number and within the 0-5 range
                const numValue = parseInt(value, 10) || 0;
                const clampedValue = Math.max(0, Math.min(5, numValue)); // Clamp between 0 and 5
                setAdjustedBuildings(prev => ({ ...prev, [type]: clampedValue }));
            };

            // Handle Save button click
            const handleSave = () => {
                onSave(adjustedBuildings); // Pass the adjusted buildings back
            };

            return (
                <div className="modal-overlay building-adjust-modal">
                    <div className="modal-content">
                        <h4>Adjust Automa Buildings</h4>
                        <p className="mb-4 text-gray-700">Set the current count for each building type (Max 5).</p>
                         <p className="mb-4 text-xs text-gray-600 italic">Scroll within this box if needed.</p> {/* Added scroll note */}

                        {/* Input fields for each building type */}
                        {Object.keys(adjustedBuildings).map(type => (
                            <div key={type} className="building-input-group">
                                <label htmlFor={`adjust-building-${type}`}>{type}:</label>
                                <input
                                    type="number"
                                    id={`adjust-building-${type}`}
                                    value={adjustedBuildings[type]}
                                    onChange={(e) => handleInputChange(type, e.target.value)}
                                    min="0"
                                    max="5"
                                />
                            </div>
                        ))}

                        {/* Buttons */}
                        <div className="modal-buttons">
                            <button className="cancel-button" onClick={onCancel}>Cancel</button>
                            <button className="confirm-button" onClick={handleSave}>Save</button>
                        </div>
                    </div>
                </div>
            );
        };

         // Resource Adjustment Modal Component
         const ResourceAdjustmentModal = ({ resources, onSave, onCancel }) => {
             // Local state for the modal input
             const [adjustedResources, setAdjustedResources] = React.useState(resources);

             // Handle input change for resource count
             const handleInputChange = (e) => {
                 // Ensure value is a number and non-negative
                 const numValue = parseInt(e.target.value, 10) || 0;
                 setAdjustedResources(Math.max(0, numValue)); // Ensure non-negative
             };

             // Handle Save button click
             const handleSave = () => {
                 onSave(adjustedResources); // Pass the adjusted resources back
             };

             return (
                 <div className="modal-overlay building-adjust-modal"> {/* Reusing some styling classes */}
                     <div className="modal-content">
                         <h4>Adjust Automa Resources</h4>
                         <p className="mb-4 text-gray-700">Set the current resource count for Automa.</p>
                          <p className="mb-4 text-xs text-gray-600 italic">Scroll within this box if needed.</p> {/* Added scroll note */}

                         {/* Input field for resources */}
                         <div className="building-input-group"> {/* Reusing input group styling */}
                             <label htmlFor="adjust-resources">Resources:</label>
                             <input
                                 type="number"
                                 id="adjust-resources"
                                 value={adjustedResources}
                                 onChange={handleInputChange}
                                 min="0"
                             />
                         </div>

                         {/* Buttons */}
                         <div className="modal-buttons">
                             <button className="cancel-button" onClick={onCancel}>Cancel</button>
                             <button className="confirm-button" onClick={handleSave}>Confirm</button>
                         </div>
                     </div>
                 </div>
             );
         };

        // Position Adjustment Modal Component
        const PositionAdjustmentModal = ({ playerPositions, automaPositions, onSave, onCancel }) => {
            // Local state for the modal inputs
            const [adjustedPlayerPositions, setAdjustedPlayerPositions] = React.useState({...playerPositions});
            const [adjustedAutomaPositions, setAdjustedAutomaPositions] = React.useState({...automaPositions});

            // Handle input change for player positions
            const handlePlayerInputChange = (track, value) => {
                // Ensure value is a number and within the 0-12 range
                const numValue = parseInt(value, 10) || 0;
                const clampedValue = Math.max(0, Math.min(12, numValue)); // Clamp between 0 and 12
                setAdjustedPlayerPositions(prev => ({ ...prev, [track]: clampedValue }));
            };

            // Handle input change for automa positions
            const handleAutomaInputChange = (track, value) => {
                // Ensure value is a number and within the 0-12 range
                const numValue = parseInt(value, 10) || 0;
                const clampedValue = Math.max(0, Math.min(12, numValue)); // Clamp between 0 and 12
                setAdjustedAutomaPositions(prev => ({ ...prev, [track]: clampedValue }));
            };


            // Handle Save button click
            const handleSave = () => {
                onSave(adjustedPlayerPositions, adjustedAutomaPositions); // Pass both adjusted positions back
            };

            return (
                <div className="modal-overlay position-adjust-modal"> {/* Use a specific class for this modal */}
                    <div className="modal-content">
                        <h4>Adjust Player and Automa Positions</h4>
                        <p className="mb-4 text-gray-700">Manually set the position for each player on each track (0-12).</p>
                         <p className="mb-4 text-xs text-gray-600 italic">Scroll within this box if needed.</p> {/* Added scroll note */}

                        {/* Input fields for each track and player/automa */}
                        {Object.keys(tracksData).map(track => (
                            <div key={track} className="track-position-group">
                                <h5>{track} Track</h5>
                                <div className="position-input-row">
                                    <label htmlFor={`adjust-player-${track}`}>Player Position:</label>
                                    <input
                                        type="number"
                                        id={`adjust-player-${track}`}
                                        value={adjustedPlayerPositions[track]}
                                        onChange={(e) => handlePlayerInputChange(track, e.target.value)}
                                        min="0"
                                        max="12"
                                    />
                                </div>
                                <div className="position-input-row mt-2"> {/* Added margin-top */}
                                    <label htmlFor={`adjust-automa-${track}`}>Automa Position:</label>
                                    <input
                                        type="number"
                                        id={`adjust-automa-${track}`}
                                        value={adjustedAutomaPositions[track]}
                                        onChange={(e) => handleAutomaInputChange(track, e.target.value)}
                                        min="0"
                                        max="12"
                                    />
                                </div>
                            </div>
                        ))}

                        {/* Buttons */}
                        <div className="modal-buttons">
                            <button className="cancel-button" onClick={onCancel}>Cancel</button>
                            <button className="confirm-button" onClick={handleSave}>Save</button>
                        </div>
                    </div>
                </div>
            );
        };


        // Confirmation Modal Component
        const ConfirmationModal = ({ message, onConfirm, onCancel }) => {
            return (
                <div className="modal-overlay">
                    <div className="modal-content">
                        <h4>Confirm Action</h4>
                        <p className="mb-4">{message}</p>
                         <p className="mb-4 text-xs text-gray-600 italic">Scroll within this box if needed.</p> {/* Added scroll note */}
                        <div className="modal-buttons">
                            <button className="cancel-button" onClick={onCancel}>Cancel</button>
                            <button className="confirm-button" onClick={onConfirm}>Confirm</button>
                        </div>
                    </div>
                </div>
            );
        };

    // Main App Component
    function App() {
        // Initial state setup - Ensure all tracks are initialized to space 0
        const initialGameState = {
            playerPositions: {
                Exploration: 0,
                Technology: 0,
                Science: 0,
                Military: 0,
                Arts: 0,
            },
            automaPositions: {
                Exploration: 0,
                Technology: 0,
                Science: 0,
                Military: 0,
                Arts: 0,
            },
            automaResources: 4, // Automa starts with 4 resources
            automaBuildings: {
                 Market: 0,
                 House: 0,
                 Farm: 0,
                 Armory: 0,
            },
             // Initialize landmarks state based on allLandmarksCategorized
             landmarks: Object.keys(allLandmarksCategorized).reduce((acc, category) => {
                 allLandmarksCategorized[category].forEach(landmark => {
                     // Create a unique key for each landmark
                     const key = category.includes('Track') ?
                         `${landmark.track}-${landmark.space}` :
                         `${landmark.name.replace(/\s+/g, '')}-${category.replace(/\s+/g, '')}`;
                     acc[key] = { name: landmark.name, status: 'available' }; // Default status is available
                 });
                 return acc;
             }, {}),

            automaColor: 'Red', // Default Automa color (will be set by setup)
            automaCharacter: 'Normal', // Default Automa character (will be set by setup)
            automaTurnMessage: '', // Message display for Automa's turn
            currentTiebreakerTrack: null, // Store the current tiebreaker permutation

            // History state
            automaHistory: [], // Array to store turn history
            turnNumber: 1, // Track the current turn number

            isSetupComplete: false, // New state to track if initial setup is done
        };


        // State for the entire game
        const [gameState, setGameState] = React.useState(initialGameState);
        const [message, setMessage] = React.useState(''); // General message state

        // State for history and undo/redo
        const [history, setHistory] = React.useState([initialGameState]);
        const [historyIndex, setHistoryIndex] = React.useState(0);
        const [isHistoryVisible, setIsHistoryVisible] = React.useState(true); // State to control history visibility

        // State for available permutations (used for Automa tiebreaker)
        const [availablePermutations, setAvailablePermutations] = React.useState(allTrackPermutations);
        // State to store the current tiebreaker track being used
        const [currentTiebreakerTrack, setCurrentTiebreakerTrack] = React.useState(null);

        // State for modals
        const [showAutomaIncomePopup, setShowAutomaIncomePopup] = React.useState(false); // State for Automa Income popup
        const [automaIncomePopupData, setAutomaIncomePopupData] = React.useState({ // State for Automa Income popup data
             resources: 0,
             buildings: { Market: 0, House: 0, Farm: 0, Armory: 0 },
             landmarks: [], // Array of landmark keys gained
        });
        const [showBuildingAdjustmentModal, setShowBuildingAdjustmentModal] = React.useState(false); // State for Building Adjustment modal
        const [showResourceAdjustmentModal, setShowResourceAdjustmentModal] = React.useState(false); // State for Resource Adjustment modal
        const [showConfirmationModal, setShowConfirmationModal] = React.useState(false); // State for Confirmation modal
        const [confirmationAction, setConfirmationAction] = React.useState(null); // Action to perform on confirmation

         // State for initial setup screen selections
         const [setupAutomaColor, setSetupAutomaColor] = React.useState('Red');
         const [setupAutomaCharacter, setSetupAutomaCharacter] = React.useState('Normal');


        // Function to update state and add to history
        const updateState = (newState) => {
            // If we are not at the end of history (meaning we've undone some moves),
            // discard the future history before adding the new state.
            const newHistory = history.slice(0, historyIndex + 1);
            setHistory([...newHistory, newState]);
            setHistoryIndex(newHistory.length);
            setGameState(newState);
        };


        // Handle Automa's Turn
        const handleAutomaTurn = () => {
            setMessage('Calculating Automa turn...');
            // Pass current state, availablePermutations, and selected character to calculation
            // Pass availablePermutations from the state
            const move = calculateAutomaMove(gameState, availablePermutations, gameState.automaCharacter);

            // Create a deep copy of the current state for modification
            const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history


            if (move.action === 'income') {
                 console.log("Automa takes Income Turn.");
                 // Show the income pop-up, initializing with current Automa state
                 setAutomaIncomePopupData({ // Use automaIncomePopupData
                     resources: gameState.automaResources, // Start with current resources
                     buildings: { ...gameState.automaBuildings }, // Start with current buildings
                     landmarks: [], // Array of landmark keys gained
                 });
                 setShowAutomaIncomePopup(true); // Use showAutomaIncomePopup
                 // Add class to body to disable scrolling
                 document.body.classList.add('modal-open');
                 // Set the Automa turn message for the panel (using the details from the move)
                 newState.automaTurnMessage = move.details;
                 // Clear the tiebreaker track state variable when income is taken
                 newState.currentTiebreakerTrack = null;


                 // Add Income action to history (will be finalized on income confirmation)
                 newState.automaHistory.push({
                     turn: gameState.turnNumber,
                     player: 'Automa', // Specify player
                     action: 'Income',
                     details: newState.automaTurnMessage // Initial message
                 });


                 // Update state and history
                 updateState(newState);


            } else if (move.action === 'advance') {
                console.log("Automa takes Advance Turn:", move);
                const { track, space, cost, permutation, details, candidateTracks } = move; // Destructure details and candidateTracks
                const oldPos = gameState.automaPositions[track];
                const newPos = space; // Use the calculated target space directly

                newState.automaPositions[track] = newPos;
                // Ensure resources do not go below zero
                newState.automaResources = Math.max(0, newState.automaResources - cost);


                // Set the Automa turn message for the panel (using the details from the move)
                newState.automaTurnMessage = details;


                 // Update the tiebreaker track state variable based on how it was used
                 // A new permutation is drawn if:
                 // 1. There is no current tiebreaker track set OR the current one is exhausted (none of its tracks are in the current candidateTracks).
                 // 2. OR the move was a direct advance (single candidate for Rule 1, 2, 3, 6, 7, 8, 9, 10, 'Special') - Rule 4 and 5 don't clear the tiebreaker on a single candidate.
                const isCurrentPermutationValidForCandidates = gameState.currentTiebreakerTrack && Array.isArray(gameState.currentTiebreakerTrack) && gameState.currentTiebreakerTrack.some(t => candidateTracks.includes(t));
                const shouldDrawNewPermutation = !isCurrentPermutationValidForCandidates || (candidateTracks.length === 1 && ![4, 5, 'Special'].includes(move.priorityRule));


                 if (shouldDrawNewPermutation) {
                     newState.currentTiebreakerTrack = permutation; // Set the new permutation
                     console.log("Tiebreaker set/retained:", newState.currentTiebreakerTrack);

                     // Remove the used permutation from availablePermutations state
                     // Only remove if a permutation was actually used (i.e., not the special logic)
                     if (permutation !== null) {
                          // FIX: Use the availablePermutations state variable directly here
                          const usedPermutationIndex = availablePermutations.findIndex(p => JSON.stringify(p) === JSON.stringify(permutation));
                          if (usedPermutationIndex !== -1) {
                               const newAvailablePermutations = availablePermutations.filter((_, index) => index !== usedPermutationIndex);
                               newState.availablePermutations = newAvailablePermutations; // Update in newState
                               console.log("Removed used permutation from available:", permutation);
                               console.log("Remaining available permutations:", newAvailablePermutations);
                          }
                     }


                 } else {
                     newState.currentTiebreakerTrack = gameState.currentTiebreakerTrack; // Keep the existing permutation
                     console.log("Tiebreaker retained:", newState.currentTiebreakerTrack);
                 }


                // Check for claimed landmarks only on forward moves
                if (newPos > oldPos) {
                    checkLandmarks(newState, track, oldPos, newPos, 'automa'); // Modify newState directly
                }

                // Check for building gain (gain building logic applies to the *new* space)
                const spaceData = tracksData[track].spacesData.find(s => s.number === newPos);
                let buildingGainMessage = '';
                if (spaceData && spaceData.benefitDetails) {
                   if (spaceData.benefitDetails.gainBuilding) {
                       const buildingType = spaceData.benefitDetails.gainBuilding;
                       newState.automaBuildings[buildingType] = Math.min(5, newState.automaBuildings[buildingType] + 1); // Cap at 5
                       buildingGainMessage = ` Automa gained 1 ${buildingType}.`;
                   } else if (spaceData.benefitDetails.gainBuildingChoice) {
                        // Automa picks the first option in the choice array
                        const buildingType = spaceData.benefitDetails.gainBuildingChoice[0];
                        newState.automaBuildings[buildingType] = Math.min(5, newState.automaBuildings[buildingType] + 1); // Cap at 5
                        buildingGainMessage = ` Automa gained 1 ${buildingType} (from choice).`;
                     }
                }

                // Add Advance action to history
                newState.automaHistory.push({
                    turn: gameState.turnNumber,
                    player: 'Automa', // Specify player
                    action: 'Advance',
                    details: newState.automaTurnMessage // Use the updated message for history
                });

                // Increment turn number after a successful advance
                newState.turnNumber += 1;


                // Update state and history
                updateState(newState);

            }
        };

        // Handle player clicking on a track space - This is for normal advances
        const handlePlayerSpaceClick = (trackName, spaceIndex) => {
            // Prevent clicking on spaces before the current player position
            if (spaceIndex <= gameState.playerPositions[trackName]) {
                setMessage(`You cannot move backward or stay on the same space.`);
                return;
            }

            // Calculate the cost to move to the clicked space
            const cost = tracksData[trackName].cost(spaceIndex);

            // Create a deep copy of the current state
            const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history


            // Update the player's position on the clicked track
            const oldPos = newState.playerPositions[trackName];
            newState.playerPositions[trackName] = spaceIndex;

            // Check for claimed landmarks (only if moving forward)
            if (spaceIndex > oldPos) {
                checkLandmarks(newState, trackName, oldPos, spaceIndex, 'player'); // Modify newState directly
            }

            // Add Player action to history
            newState.automaHistory.push({
                turn: gameState.turnNumber, // Use the current turn number
                player: 'Player', // Specify player
                action: 'Advance',
                details: `Player advanced on ${trackName} track to space ${spaceIndex}.` // Simple detail for player move
            });


            // Update state with the new player position and potentially claimed landmarks
            updateState(newState);
            setMessage(`Player moved to space ${spaceIndex} on the ${trackName} track.`);
        };

         // Handle advancing player by one space
         const handleAdvancePlayerOneSpace = (trackName) => {
             const currentPos = gameState.playerPositions[trackName];
             const nextPos = currentPos + 1;

             // Prevent advancing past space 12
             if (nextPos > 12) {
                 setMessage(`Player is already at the end of the ${trackName} track.`);
                 return;
             }

             // Create a deep copy of the current state
             const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history

             // Update the player's position
             newState.playerPositions[trackName] = nextPos;

             // Check for claimed landmarks
             checkLandmarks(newState, trackName, currentPos, nextPos, 'player'); // Modify newState directly

             // Add Player Advance 1 Space action to history
             newState.automaHistory.push({
                 turn: gameState.turnNumber,
                 player: 'Player',
                 action: 'Advance 1 Space',
                 details: `Player advanced 1 space on ${trackName} track to space ${nextPos}.`
             });

             // Update state and history
             updateState(newState);
             setMessage(`Player advanced 1 space on the ${trackName} track.`);
         };

         // Handle advancing automa by one space (Manual Advance - No Benefits)
         const handleAdvanceAutomaOneSpaceNoBenefits = (trackName) => {
             const currentPos = gameState.automaPositions[trackName];
             const nextPos = currentPos + 1;

             // Prevent advancing past space 12
             if (nextPos > 12) {
                 setMessage(`Automa is already at the end of the ${trackName} track.`);
                 return;
             }

             // Create a deep copy of the current state
             const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history

             // Update the automa's position (No resource deduction here)
             newState.automaPositions[trackName] = nextPos;

             // Check for claimed landmarks (still claim landmarks on a free move)
             checkLandmarks(newState, trackName, currentPos, nextPos, 'automa'); // Modify newState directly

             // No building gain logic here for manual advance without benefits

             // Add Manual Automa Advance (No Benefits) action to history
             newState.automaHistory.push({
                 turn: gameState.turnNumber,
                 player: 'Manual Automa', // Indicate manual action
                 action: 'Advance 1 Space (No Benefits)',
                 details: `Automa manually advanced 1 space on ${trackName} track to space ${nextPos} (No Benefits).` // Detail it was manual and no benefits
             });

             // Update state and history
             updateState(newState);
             setMessage(`Automa manually advanced 1 space on the ${trackName} track (No Benefits).`);
         };

          // Handle advancing automa by one space (Manual Advance - With Benefits)
          const handleAdvanceAutomaOneSpaceWithBenefits = (trackName) => {
              const currentPos = gameState.automaPositions[trackName];
              const nextPos = currentPos + 1;

              // Prevent advancing past space 12
              if (nextPos > 12) {
                  setMessage(`Automa is already at the end of the ${trackName} track.`);
                  return;
              }

              // Create a deep copy of the current state
              const newState = JSON.parse(JSON.stringify(gameState));
              newState.automaHistory = [...gameState.automaHistory]; // Copy history

              // Update the automa's position (No resource deduction here)
              newState.automaPositions[trackName] = nextPos;

              // Check for claimed landmarks
              checkLandmarks(newState, trackName, currentPos, nextPos, 'automa'); // Modify newState directly

              // Check for building gain (gain building logic applies to the *new* space)
              const spaceData = tracksData[trackName].spacesData.find(s => s.number === nextPos);
              let buildingGainMessage = '';
              if (spaceData && spaceData.benefitDetails) {
                   if (spaceData.benefitDetails.gainBuilding) {
                       const buildingType = spaceData.benefitDetails.gainBuilding;
                       newState.automaBuildings[buildingType] = Math.min(5, newState.automaBuildings[buildingType] + 1); // Cap at 5
                       buildingGainMessage = ` Automa gained 1 ${buildingType}.`;
                   } else if (spaceData.benefitDetails.gainBuildingChoice) {
                        // Automa picks the first option in the choice array
                        const buildingType = spaceData.benefitDetails.gainBuildingChoice[0];
                        newState.automaBuildings[buildingType] = Math.min(5, newState.automaBuildings[buildingType] + 1); // Cap at 5
                        buildingGainMessage = ` Automa gained 1 ${buildingType} (from choice).`;
                     }
                }

              // Add Manual Automa Advance (With Benefits) action to history
              newState.automaHistory.push({
                  turn: gameState.turnNumber,
                  player: 'Manual Automa', // Indicate manual action
                  action: 'Advance 1 Space (Gain Benefits)',
                  details: `Automa manually advanced 1 space on ${trackName} track to space ${nextPos} (Gain Benefits).${buildingGainMessage}` // Detail it was manual and gained benefits
              });

              // Update state and history
              updateState(newState);
              setMessage(`Automa manually advanced 1 space on the ${trackName} track (Gain Benefits).${buildingGainMessage}`);
          };


        // Handle input changes in the automa income pop-up
        const handleAutomaIncomeInputChange = (e) => { // Renamed handler
            const { name, value, type } = e.target;
            if (type === 'number') {
                 // Ensure number input is parsed as integer, default to 0 if invalid
                 setAutomaIncomePopupData(prev => ({ ...prev, [name]: parseInt(value, 10) || 0 })); // Use automaIncomePopupData
            } else if (name.startsWith('building-')) {
                 const buildingType = name.replace('building-', '');
                 // Ensure building number input is parsed as integer, default to 0 if invalid, and cap at 5
                 setAutomaIncomePopupData(prev => ({ // Use automaIncomePopupData
                     ...prev,
                     buildings: {
                         ...prev.buildings,
                         [buildingType]: Math.min(5, parseInt(value, 10) || 0) // Cap at 5
                     }
                 }));
            } else if (name === 'landmark-gained') {
                 // Handle selecting landmarks gained - assuming a single select for simplicity
                 // Store the selected landmark key in an array
                 setAutomaIncomePopupData(prev => ({ ...prev, landmarks: value ? [value] : [] })); // Use automaIncomePopupData
            }
        };

        // Handle confirming the automa income pop-up
        const handleConfirmAutomaIncome = () => { // Renamed handler
             // Create a deep copy of the current state to apply income results
             const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history


             // Apply changes from the pop-up data to the new state
             newState.automaResources = automaIncomePopupData.resources; // Use automaIncomePopupData
             // Copy the buildings object to avoid direct mutation of automaIncomePopupData
             // Buildings are already capped at 5 by handleAutomaIncomeInputChange
             newState.automaBuildings = { ...automaIncomePopupData.buildings }; // Use automaIncomePopupData

             // Update landmark statuses based on the pop-up input
             automaIncomePopupData.landmarks.forEach(landmarkKey => { // Use automaIncomePopupData
                 // Check if the landmark key exists in the state before updating
                 if (newState.landmarks[landmarkKey]) {
                     // Set status to 'automa' for landmarks gained during income
                     newState.landmarks[landmarkKey].status = 'automa';
                 } else {
                     console.warn(`Attempted to claim non-existent landmark with key: ${landmarkKey}`);
                 }
             });

             // Clear the Automa turn message after income is resolved
             newState.automaTurnMessage = '';
             // Clear the tiebreaker track after income is resolved
             newState.currentTiebreakerTrack = null;

             // Update the history entry for this turn with the final income details
             const currentTurnHistoryIndex = newState.automaHistory.findIndex(entry => entry.turn === gameState.turnNumber && entry.player === 'Automa' && entry.action === 'Income');
             if (currentTurnHistoryIndex !== -1) {
                  newState.automaHistory[currentTurnHistoryIndex].details = `[${gameState.automaCharacter}] Took Income Turn. Resources: ${automaIncomePopupData.resources}, Buildings Gained: Market(${automaIncomePopupData.buildings.Market}), House(${automaIncomePopupData.buildings.House}), Farm(${automaIncomePopupData.buildings.Farm}), Armory(${automaIncomePopupData.buildings.Armory}). Landmarks Gained: ${automaIncomePopupData.landmarks.length > 0 ? automaIncomePopupData.landmarks.map(key => gameState.landmarks[key]?.name || 'Unknown').join(', ') : 'None'}.`; // Use automaIncomePopupData
             }


             // Increment turn number after income is resolved
             newState.turnNumber += 1;


             // Update state with the new income results, adding to history
             updateState(newState);

             // Hide the pop-up
             setShowAutomaIncomePopup(false); // Use showAutomaIncomePopup
             // Remove class from body to re-enable scrolling
             document.body.classList.remove('modal-open');
             setMessage('Automa Income Turn results confirmed.');
        };

        // Handle canceling the automa income pop-up
        const handleCancelAutomaIncome = () => { // Renamed handler
            // Simply hide the pop-up without changing state
            setShowAutomaIncomePopup(false); // Use showAutomaIncomePopup
            // Remove class from body to re-enable scrolling
            document.body.classList.remove('modal-open');
            setMessage('Automa Income Turn input canceled.');
             // Clear the Automa turn message if income is canceled
             setGameState(prevState => ({ ...prevState, automaTurnMessage: '', currentTiebreakerTrack: null }));
             // Remove the incomplete income history entry
             setGameState(prevState => ({
                 ...prevState,
                 automaHistory: prevState.automaHistory.filter(entry => !(entry.turn === prevState.turnNumber && entry.player === 'Automa' && entry.action === 'Income' && entry.details.includes('No affordable advance possible')))
             }));
        };

        // Handle opening the building adjustment modal
        const handleOpenBuildingAdjustmentModal = () => {
            setShowBuildingAdjustmentModal(true);
             // Add class to body to disable scrolling
            document.body.classList.add('modal-open');
        };

        // Handle saving building adjustments
        const handleSaveBuildingAdjustments = (adjustedBuildings) => {
             // Create a deep copy of the current state
             const newState = JSON.parse(JSON.stringify(gameState));
             // Update the automa buildings with the adjusted values
             // The values are already capped at 5 by the modal's handleInputChange
             newState.automaBuildings = adjustedBuildings;
             // Update the state and history
             updateState(newState);
             // Close the modal
             setShowBuildingAdjustmentModal(false);
             // Remove class from body to re-enable scrolling
             document.body.classList.remove('modal-open');
             setMessage('Automa buildings manually adjusted.');
        };

        // Handle canceling building adjustments
        const handleCancelBuildingAdjustments = () => {
            // Simply close the modal
            setShowBuildingAdjustmentModal(false);
            // Remove class from body to re-enable scrolling
            document.body.classList.remove('modal-open');
            setMessage('Automa building adjustment canceled.');
        };

         // Handle opening the resource adjustment modal
        const handleOpenResourceAdjustmentModal = () => {
            setShowResourceAdjustmentModal(true);
             // Add class to body to disable scrolling
            document.body.classList.add('modal-open');
        };

         // Handle saving resource adjustments
        const handleSaveResourceAdjustments = (adjustedResources) => {
             // Create a deep copy of the current state
             const newState = JSON.parse(JSON.stringify(gameState));
             // Update the automa resources with the adjusted value
             newState.automaResources = adjustedResources;
             // Update the state and history
             updateState(newState);
             // Close the modal
             setShowResourceAdjustmentModal(false);
             // Remove class from body to re-enable scrolling
             document.body.classList.remove('modal-open');
             setMessage('Automa resource adjustment canceled.');
        };

         // Handle canceling resource adjustments
         const handleCancelResourceAdjustments = () => {
             // Simply close the modal
             setShowResourceAdjustmentModal(false);
             // Remove class from body to re-enable scrolling
             document.body.classList.remove('modal-open');
             setMessage('Automa resource adjustment canceled.');
         };

        // State for the position adjustment modal
        const [showPositionAdjustmentModal, setShowPositionAdjustmentModal] = React.useState(false);

        // Handle opening the position adjustment modal
        const handleOpenPositionAdjustmentModal = () => {
            setShowPositionAdjustmentModal(true);
            document.body.classList.add('modal-open');
        };

        // Handle saving position adjustments
        const handleSavePositionAdjustments = (adjustedPlayerPositions, adjustedAutomaPositions) => {
            // Create a deep copy of the current state
            const newState = JSON.parse(JSON.stringify(gameState));
            newState.automaHistory = [...gameState.automaHistory]; // Copy history

            const tracks = Object.keys(tracksData);
            let playerChanges = [];
            let automaChanges = [];

            // Update player positions and check for landmarks crossed
            tracks.forEach(track => {
                const oldPos = newState.playerPositions[track];
                const newPos = adjustedPlayerPositions[track];
                if (oldPos !== newPos) {
                    newState.playerPositions[track] = newPos;
                    playerChanges.push(`${track} to ${newPos}`);
                    // Check for landmarks claimed by the player if moving forward
                    if (newPos > oldPos) {
                         checkLandmarks(newState, track, oldPos, newPos, 'player');
                    }
                }
            });

            // Update automa positions and check for landmarks claimed
            tracks.forEach(track => {
                const oldPos = newState.automaPositions[track];
                const newPos = adjustedAutomaPositions[track];
                if (oldPos !== newPos) {
                    newState.automaPositions[track] = newPos;
                    automaChanges.push(`${track} to ${newPos}`);
                     // Check for landmarks claimed by Automa if moving forward
                    if (newPos > oldPos) {
                        checkLandmarks(newState, track, oldPos, newPos, 'automa');
                    }
                }
            });

            let historyDetails = 'Manual Position Adjustment: ';
            if (playerChanges.length > 0) {
                 historyDetails += `Player moved on ${playerChanges.join(', ')}.`;
            }
            if (automaChanges.length > 0) {
                 if (playerChanges.length > 0) historyDetails += ' '; // Add space if both made changes
                 historyDetails += `Automa moved on ${automaChanges.join(', ')}.`;
            }
            if (playerChanges.length === 0 && automaChanges.length === 0) {
                 historyDetails += 'No changes made.';
            }


             // Add Manual Adjustment action to history
             newState.automaHistory.push({
                 turn: gameState.turnNumber, // Use the current turn number
                 player: 'Manual', // Indicate manual action
                 action: 'Adjust Positions',
                 details: historyDetails // Detail the changes made
             });


            // Update state and history
            updateState(newState);

            // Close the modal
            setShowPositionAdjustmentModal(false);
            document.body.classList.remove('modal-open');
            setMessage('Player and Automa positions manually adjusted.');
        };

        // Handle canceling position adjustments
        const handleCancelPositionAdjustments = () => {
            // Simply close the modal
            setShowPositionAdjustmentModal(false);
            document.body.classList.remove('modal-open');
            setMessage('Position adjustment canceled.');
        };


        // Handle initiating game restart
        const handleRestartGame = () => {
            // Show confirmation modal
            setConfirmationAction('restart');
            setShowConfirmationModal(true);
             document.body.classList.add('modal-open');
        };

        // Handle confirming game restart
        const handleConfirmRestart = () => {
             // Reset all state to initial values
             setGameState(initialGameState);
             setHistory([initialGameState]);
             setHistoryIndex(0);
             setAvailablePermutations(allTrackPermutations); // Reset permutations
             setCurrentTiebreakerTrack(null); // Clear current tiebreaker
             setIsHistoryVisible(true); // Show history on restart
             setMessage('Game restarted.');
             // Close modal
             setShowConfirmationModal(false);
             document.body.classList.remove('modal-open');
             setConfirmationAction(null);
             // Show the setup screen again
             setGameState(prevState => ({ ...prevState, isSetupComplete: false }));
        };

        // Handle canceling confirmation
        const handleCancelConfirmation = () => {
             // Close modal without performing action
             setShowConfirmationModal(false);
             document.body.classList.remove('modal-open');
             setConfirmationAction(null);
             setMessage('Action canceled.');
        };


        // Undo function
        const handleUndo = () => {
            // Check if there's a previous state in history
            if (historyIndex > 0) {
                // Get the previous state from history
                const previousState = history[historyIndex - 1];
                // Decrement the history index
                setHistoryIndex(historyIndex - 1);
                // Set the game state to the next state
                setGameState(previousState);
                // Restore available permutations and tiebreaker from the previous state
                setAvailablePermutations(previousState.availablePermutations || allTrackPermutations); // Use saved or default
                setCurrentTiebreakerTrack(previousState.currentTiebreakerTrack);
                setMessage('Undo successful.');
            } else {
                // If already at the beginning of history, cannot undo
                setMessage('Cannot undo further.');
            }
        };

        // Redo function
        const handleRedo = () => {
            // Check if there's a future state in history
            if (historyIndex < history.length - 1) {
                // Get the next state from history
                const nextState = history[historyIndex + 1];
                // Increment the history index
                setHistoryIndex(historyIndex + 1);
                // Set the game state to the next state
                setGameState(nextState);
                 // Restore available permutations and tiebreaker from the next state
                setAvailablePermutations(nextState.availablePermutations || allTrackPermutations); // Use saved or default
                setCurrentTiebreakerTrack(nextState.currentTiebreakerTrack);
                setMessage('Redo successful.');
            } else {
                // If already at the end of history, cannot redo
                setMessage('Cannot redo further.');
            }
        };

         // Handle Automa color change (for setup screen)
         const handleSetupAutomaColorChange = (color) => {
             setSetupAutomaColor(color);
         };

         // Handle Automa character change (for setup screen)
         const handleSetupAutomaCharacterChange = (character) => {
             setSetupAutomaCharacter(character);
         };

         // Handle starting the game from setup screen
         const handleStartGame = () => {
             // Create a new initial state with the selected color and character
             const newInitialState = {
                 ...initialGameState,
                 automaColor: setupAutomaColor,
                 automaCharacter: setupAutomaCharacter,
                 isSetupComplete: true, // Mark setup as complete
             };

             // Reset all state to the new initial values
             setGameState(newInitialState);
             setHistory([newInitialState]); // Start history with the new initial state
             setHistoryIndex(0);
             setAvailablePermutations(allTrackPermutations); // Reset permutations for the new game
             setCurrentTiebreakerTrack(null); // Clear tiebreaker
             setIsHistoryVisible(true); // Show history on start
             setMessage(`Game started with Automa color: ${setupAutomaColor}, Character: ${setupAutomaCharacter}.`);
         };


         // Handle manual landmark status change
         const handleLandmarkStatusChange = (landmarkKey, newStatus) => {
             // Create a deep copy of the state
             const newState = JSON.parse(JSON.stringify(gameState));

             // Find the landmark by its key and update its status
             if (newState.landmarks[landmarkKey]) {
                 newState.landmarks[landmarkKey].status = newStatus;
                 // Update state and history
                 updateState(newState);
                 // Find the landmark name for the message
                 const landmarkName = newState.landmarks[landmarkKey].name;
                 setMessage(`Status of ${landmarkName} updated to ${newStatus}.`);
             } else {
                 console.warn(`Attempted to change status of non-existent landmark with key: ${landmarkKey}`);
                 setMessage(`Error: Could not find landmark with key ${landmarkKey}.`);
             }
         };

         // Handle copying game history to clipboard - REMOVED handleCopyHistory function

         // Handle initiating Player Income turn (Now just records history)
         const handlePlayerIncome = () => {
             // Create a deep copy of the current state
             const newState = JSON.parse(JSON.stringify(gameState));
             newState.automaHistory = [...gameState.automaHistory]; // Copy history

             // Add Player Income action to history
             newState.automaHistory.push({
                 turn: gameState.turnNumber, // Use the current turn number
                 player: 'Player', // Specify player
                 action: 'Income',
                 details: `Player took an Income Turn.` // Simple detail for player income
             });

             // Increment turn number after player income
             newState.turnNumber += 1;

             // Update state with the new history and incremented turn number
             updateState(newState);

             setMessage('Player Income Turn recorded.');
         };

         // Toggle history visibility
         const toggleHistoryVisibility = () => {
             setIsHistoryVisible(!isHistoryVisible);
         };


        return (
            <div className="container mx-auto p-4">
                 {/* Conditional rendering: Setup screen or main game */}
                 {!gameState.isSetupComplete ? (
                     <div className="setup-screen">
                         <div className="setup-content">
                             <h2>Setup Automa</h2>
                             {/* Automa Color Selector */}
                             <div className="setup-input-group">
                                 <label htmlFor="setup-automa-color">Automa Color:</label>
                                 <select
                                     id="setup-automa-color"
                                     value={setupAutomaColor}
                                     onChange={(e) => handleSetupAutomaColorChange(e.target.value)}
                                 >
                                     <option value="Red">Red</option>
                                     <option value="Blue">Blue</option>
                                     <option value="Green">Green</option>
                                     <option value="Yellow">Yellow</option>
                                     <option value="Milky White">Milky White</option>
                                 </select>
                             </div>

                             {/* Automa Character Selector */}
                             <div className="setup-input-group">
                                 <label htmlFor="setup-automa-character">Automa Character:</label>
                                 <select
                                     id="setup-automa-character"
                                     value={setupAutomaCharacter}
                                     onChange={(e) => handleSetupAutomaCharacterChange(e.target.value)}
                                 >
                                     <option value="Normal">Normal</option>
                                     <option value="Aggressive">Aggressive</option>
                                     <option value="Strategic">Strategic</option>
                                     <option value="Peaceful">Peaceful</option>
                                     <option value="Revengeful">Revengeful</option>
                                 </select>
                             </div>

                             {/* Start Game Button */}
                             <button
                                 className="start-game-button"
                                 onClick={handleStartGame}
                             >
                                 Start Game
                             </button>
                         </div>
                     </div>
                 ) : (
                     /* Main Game UI */
                     <>
                         <h1 className="text-3xl font-bold mb-8 text-center text-gray-800">Tapestry Automa Tracker</h1>

                         {/* General Message display area */}
                         {message && !gameState.automaTurnMessage && ( /* Only show if there's a message and no specific automa turn message */
                             <div className="mb-6 p-4 bg-blue-200 text-blue-800 rounded-lg shadow-md">
                                 {message}
                             </div>
                         )}


                         {/* Automa Panel Component */}
                         <AutomaPanel
                             buildings={gameState.automaBuildings}
                             automaLandmarks={Object.keys(gameState.landmarks)
                                 .filter(key => gameState.landmarks[key].status === 'automa')
                                 .map(key => ({ key, name: gameState.landmarks[key].name }))
                             }
                             onAdjustBuildings={handleOpenBuildingAdjustmentModal}
                             onAdjustResources={handleOpenResourceAdjustmentModal}
                             onAdjustPositions={handleOpenPositionAdjustmentModal}
                             automaColor={gameState.automaColor}
                             onAutomaColorChange={handleSetupAutomaColorChange}
                             automaCharacter={gameState.automaCharacter}
                             onAutomaCharacterChange={handleSetupAutomaCharacterChange}
                             automaTurnMessage={gameState.automaTurnMessage}
                             tiebreakerTrack={gameState.currentTiebreakerTrack}
                             isSetupComplete={gameState.isSetupComplete}
                             automaResources={gameState.automaResources} /* Pass automaResources */
                         />

                         {/* Button Group 1: Under Automa Panel */}
                         <div className="button-group">
                              <button
                                  className={`automa-turn-button`}
                                  onClick={handleAutomaTurn}
                              >
                                  Automa Turn
                              </button>
                              <button
                                  className="player-income-button"
                                  onClick={handlePlayerIncome}
                                  >
                                  Player Income
                              </button>
                              <button
                                  className={`undo-button`}
                                  onClick={handleUndo}
                                  disabled={historyIndex <= 0}
                              >
                                  Undo
                              </button>
                              <button
                                  className={`redo-button`}
                                  onClick={handleRedo}
                                  disabled={historyIndex >= history.length - 1}
                              >
                                  Redo
                              </button>
                              <button
                                  className="restart-button"
                                  onClick={handleRestartGame}
                              >
                                  Restart Game
                              </button>
                          </div>


                         {/* Automa History Section */}
                         <div className="mt-8 mb-8 p-4 border rounded-lg shadow-md bg-gray-100 automa-history">
                             <div className="flex justify-between items-center mb-4">
                                 <h3 className="text-xl font-bold">Game History</h3>
                                 <button
                                     className="px-4 py-2 rounded font-bold bg-gray-600 hover:bg-gray-700 text-white text-sm"
                                     onClick={toggleHistoryVisibility}
                                 >
                                     {isHistoryVisible ? 'Hide History' : 'Show History'}
                                 </button>
                             </div>
                             {isHistoryVisible && (
                                 <>
                                     {gameState.automaHistory.length > 0 ? (
                                         <ul className="list-disc list-inside ml-4">
                                             {gameState.automaHistory.map((entry, index) => (
                                                 <li key={index} className="mb-2">
                                                     <span className="font-semibold">Turn {entry.turn} ({entry.player}):</span> {entry.details}
                                                 </li>
                                              ))}
                                         </ul>
                                     ) : (
                                         <p>No turns recorded yet.</p>
                                     )}
                                 </>
                             )}
                         </div>


                         {/* Render each track */}
                         {Object.keys(tracksData).map((trackName, index) => (
                             <React.Fragment key={trackName}>
                                 <Track
                                     key={trackName}
                                     name={trackName}
                                     spaces={13}
                                     playerPos={gameState.playerPositions[trackName]}
                                     automaPos={gameState.automaPositions[trackName]}
                                     landmarks={gameState.landmarks}
                                     onSpaceClick={handlePlayerSpaceClick}
                                     automaColor={gameState.automaColor}
                                     tracksData={tracksData}
                                     getTier={getTier}
                                     onAdvancePlayerOneSpace={handleAdvancePlayerOneSpace}
                                     onAdvanceAutomaOneSpaceNoBenefits={handleAdvanceAutomaOneSpaceNoBenefits}
                                     onAdvanceAutomaOneSpaceWithBenefits={handleAdvanceAutomaOneSpaceWithBenefits}
                                     gameState={gameState}
                                 />
                                 {/* Button Group 2: Between Technology and Science */}
                                 {trackName === 'Technology' && (
                                      <div className="button-group">
                                          <button
                                              className={`automa-turn-button`}
                                              onClick={handleAutomaTurn}
                                          >
                                              Automa Turn
                                          </button>
                                          <button
                                              className="player-income-button"
                                              onClick={handlePlayerIncome}
                                          >
                                              Player Income
                                          </button>
                                          <button
                                              className={`undo-button`}
                                              onClick={handleUndo}
                                              disabled={historyIndex <= 0}
                                          >
                                              Undo
                                          </button>
                                          <button
                                              className={`redo-button`}
                                              onClick={handleRedo}
                                              disabled={historyIndex >= history.length - 1}
                                          >
                                              Redo
                                          </button>
                                          <button
                                              className="restart-button"
                                              onClick={handleRestartGame}
                                          >
                                              Restart Game
                                          </button>
                                      </div>
                                 )}
                             </React.Fragment>
                         ))}

                          {/* Button Group 3: Under Arts Track */}
                          <div className="button-group">
                              <button
                                  className={`automa-turn-button`}
                                  onClick={handleAutomaTurn}
                              >
                                  Automa Turn
                              </button>
                              <button
                                  className="player-income-button"
                                  onClick={handlePlayerIncome}
                              >
                                  Player Income
                              </button>
                              <button
                                  className={`undo-button`}
                                  onClick={handleUndo}
                                  disabled={historyIndex <= 0}
                                  >
                                  Undo
                                  </button>
                              <button
                                  className={`redo-button`}
                                  onClick={handleRedo}
                                  disabled={historyIndex >= history.length - 1}
                              >
                                  Redo
                              </button>
                              <button
                                  className="restart-button"
                                  onClick={handleRestartGame}
                              >
                                  Restart Game
                              </button>
                          </div>


                         {/* Section for manual landmark status control */}
                         <div className="mt-10 p-6 border rounded-lg shadow-xl bg-gray-200 landmark-control-section">
                             <h3 className="text-xl font-bold mb-4 text-gray-700">Landmark Status Control</h3>
                             <div className="landmark-control-grid">
                                 {/* Iterate through categories and then landmarks within each category */}
                                 {Object.keys(allLandmarksCategorized).map(category => (
                                     <div key={category} className="landmark-group">
                                         <h4>{category}</h4>
                                         {allLandmarksCategorized[category].map(landmark => {
                                              // Create a unique key based on name and source/track+space
                                              const key = category.includes('Track') ?
                                                  `${landmark.track}-${landmark.space}` : // Key for track landmarks
                                                  `${landmark.name.replace(/\s+/g, '')}-${category.replace(/\s+/g, '')}`; // Key for other landmarks

                                              // Get the current status from the gameState, defaulting to 'available' if not found
                                              const currentStatus = gameState.landmarks[key]?.status || 'available';

                                              return (
                                                  <div key={key} className="landmark-item">
                                                      <span>{landmark.name}
                                                         {/* Display track and space for track landmarks */}
                                                         {category.includes('Track') && ` (${landmark.track} Space ${landmark.space})`}
                                                      </span>
                                                      {/* Select dropdown to change landmark status */}
                                                      <select
                                                          value={currentStatus}
                                                          onChange={(e) => handleLandmarkStatusChange(key, e.target.value)}
                                                      >
                                                          <option value="available">Available</option>
                                                          <option value="player">Claimed by Player</option>
                                                          <option value="automa">Claimed by Automa</option>
                                                          <option value="gone">Gone (Not Claimed)</option>
                                                      </select>
                                                  </div>
                                              );
                                         })}
                                     </div>
                                 ))}
                             </div>
                         </div>


                         {/* Automa Income Popup Modal */}
                          {showAutomaIncomePopup && (
                              <div className="modal-overlay">
                                  <div className="modal-content">
                                      <h4>Automa Income Turn</h4>
                                      <p className="mb-4 text-gray-700">Input the results of Automa's Income Turn.</p>
                                       <p className="mb-4 text-xs text-gray-600 italic">Scroll within this box if needed.</p> {/* Added scroll note */}

                                      {/* Resources Input */}
                                      <div className="mb-4">
                                          <label htmlFor="resources">Total Resources:</label>
                                          <input
                                              type="number"
                                              id="resources"
                                              name="resources"
                                              value={automaIncomePopupData.resources}
                                              onChange={handleAutomaIncomeInputChange}
                                              min="0"
                                          />
                                      </div>

                                      {/* Buildings Gained Inputs */}
                                      <div className="mb-4">
                                          <span className="block font-semibold mb-2">Buildings Gained (Max 5 each):</span>
                                          {Object.keys(automaIncomePopupData.buildings).map(type => (
                                              <div key={`income-${type}`} className="building-input-group">
                                                  <label htmlFor={`building-${type}`}>{type}:</label>
                                                  <input
                                                      type="number"
                                                      id={`building-${type}`}
                                                      name={`building-${type}`}
                                                      value={automaIncomePopupData.buildings[type]}
                                                      onChange={handleAutomaIncomeInputChange}
                                                      min="0"
                                                      max="5"
                                                  />
                                              </div>
                                          ))}
                                      </div>

                                      {/* Landmarks Gained Select (Simplified: select one if any) */}
                                      {/* Note: This is a simplification; a real implementation might need multi-select or more complex input */}
                                      <div className="mb-4">
                                          <label htmlFor="landmark-gained">Landmark Gained (if any):</label>
                                          <select
                                              id="landmark-gained"
                                              name="landmark-gained"
                                              value={automaIncomePopupData.landmarks[0] || ''} // Use the first landmark key if exists
                                              onChange={handleAutomaIncomeInputChange}
                                          >
                                              <option value="">None</option>
                                              {/* Filter available landmarks for selection */}
                                              {Object.keys(gameState.landmarks)
                                                  .filter(key => gameState.landmarks[key].status === 'available')
                                                  .map(key => (
                                                      <option key={key} value={key}>{gameState.landmarks[key].name}</option>
                                                  ))}
                                          </select>
                                      </div>

                                      {/* Buttons */}
                                      <div className="modal-buttons">
                                          <button className="cancel-button" onClick={handleCancelAutomaIncome}>Cancel</button>
                                          <button className="confirm-button" onClick={handleConfirmAutomaIncome}>Confirm</button>
                                      </div>
                                  </div>
                              </div>
                          )}
                         {/* Player Income Modal - Removed */}

                         {/* Building Adjustment Modal */}
                          {showBuildingAdjustmentModal && (
                              <BuildingAdjustmentModal
                                  buildings={gameState.automaBuildings} // Pass current buildings to the modal
                                  onSave={handleSaveBuildingAdjustments} // Pass save handler
                                  onCancel={handleCancelBuildingAdjustments} // Pass cancel handler
                              />
                          )}

                          {/* Resource Adjustment Modal */}
                          {showResourceAdjustmentModal && (
                              <ResourceAdjustmentModal
                                  resources={gameState.automaResources} // Pass current resources to the modal
                                  onSave={handleSaveResourceAdjustments} // Pass save handler
                                  onCancel={handleCancelResourceAdjustments} // Pass cancel handler
                              />
                          )}

                          {/* Position Adjustment Modal */}
                          {showPositionAdjustmentModal && (
                              <PositionAdjustmentModal
                                  playerPositions={gameState.playerPositions} // Pass current player positions
                                  automaPositions={gameState.automaPositions} // Pass current automa positions
                                  onSave={handleSavePositionAdjustments} // Pass save handler
                                  onCancel={handleCancelPositionAdjustments} // Pass cancel handler
                              />
                          )}


                          {/* Confirmation Modal */}
                          {showConfirmationModal && (
                              <ConfirmationModal
                                  message={confirmationAction === 'restart' ? 'Are you sure you want to restart the game? This will reset all progress.' : 'Are you sure?'}
                                  onConfirm={confirmationAction === 'restart' ? handleConfirmRestart : () => {}} // Call appropriate handler based on action
                                  onCancel={handleCancelConfirmation}
                              />
                          )}
                     </>
                 )}


            </div>
        );
    }

    // Render the App into the root element
    try {
        const container = document.getElementById('app');
        if (container) {
            // Use createRoot for React 18+ rendering
            const root = ReactDOM.createRoot(container);
            root.render(<App />); // Render the main App component
        } else {
            // Log an error if the root element is not found
            console.error("Could not find root element with id 'app'");
        }
    } catch (error) {
        // Catch and log any errors during the rendering process
        console.error("Error rendering React app:", error);
    }

    </script>
</body>
</html>
